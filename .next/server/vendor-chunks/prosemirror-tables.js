"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-tables";
exports.ids = ["vendor-chunks/prosemirror-tables"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-tables/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-tables/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellBookmark: () => (/* binding */ CellBookmark),\n/* harmony export */   CellSelection: () => (/* binding */ CellSelection),\n/* harmony export */   ResizeState: () => (/* binding */ ResizeState),\n/* harmony export */   TableMap: () => (/* binding */ TableMap),\n/* harmony export */   TableView: () => (/* binding */ TableView),\n/* harmony export */   __clipCells: () => (/* binding */ clipCells),\n/* harmony export */   __insertCells: () => (/* binding */ insertCells),\n/* harmony export */   __pastedCells: () => (/* binding */ pastedCells),\n/* harmony export */   addColSpan: () => (/* binding */ addColSpan),\n/* harmony export */   addColumn: () => (/* binding */ addColumn),\n/* harmony export */   addColumnAfter: () => (/* binding */ addColumnAfter),\n/* harmony export */   addColumnBefore: () => (/* binding */ addColumnBefore),\n/* harmony export */   addRow: () => (/* binding */ addRow),\n/* harmony export */   addRowAfter: () => (/* binding */ addRowAfter),\n/* harmony export */   addRowBefore: () => (/* binding */ addRowBefore),\n/* harmony export */   cellAround: () => (/* binding */ cellAround),\n/* harmony export */   cellNear: () => (/* binding */ cellNear),\n/* harmony export */   colCount: () => (/* binding */ colCount),\n/* harmony export */   columnIsHeader: () => (/* binding */ columnIsHeader),\n/* harmony export */   columnResizing: () => (/* binding */ columnResizing),\n/* harmony export */   columnResizingPluginKey: () => (/* binding */ columnResizingPluginKey),\n/* harmony export */   deleteCellSelection: () => (/* binding */ deleteCellSelection),\n/* harmony export */   deleteColumn: () => (/* binding */ deleteColumn),\n/* harmony export */   deleteRow: () => (/* binding */ deleteRow),\n/* harmony export */   deleteTable: () => (/* binding */ deleteTable),\n/* harmony export */   findCell: () => (/* binding */ findCell),\n/* harmony export */   findCellPos: () => (/* binding */ findCellPos),\n/* harmony export */   findCellRange: () => (/* binding */ findCellRange),\n/* harmony export */   findTable: () => (/* binding */ findTable),\n/* harmony export */   fixTables: () => (/* binding */ fixTables),\n/* harmony export */   fixTablesKey: () => (/* binding */ fixTablesKey),\n/* harmony export */   goToNextCell: () => (/* binding */ goToNextCell),\n/* harmony export */   handlePaste: () => (/* binding */ handlePaste),\n/* harmony export */   inSameTable: () => (/* binding */ inSameTable),\n/* harmony export */   isInTable: () => (/* binding */ isInTable),\n/* harmony export */   mergeCells: () => (/* binding */ mergeCells),\n/* harmony export */   moveCellForward: () => (/* binding */ moveCellForward),\n/* harmony export */   moveTableColumn: () => (/* binding */ moveTableColumn2),\n/* harmony export */   moveTableRow: () => (/* binding */ moveTableRow2),\n/* harmony export */   nextCell: () => (/* binding */ nextCell),\n/* harmony export */   pointsAtCell: () => (/* binding */ pointsAtCell),\n/* harmony export */   removeColSpan: () => (/* binding */ removeColSpan),\n/* harmony export */   removeColumn: () => (/* binding */ removeColumn),\n/* harmony export */   removeRow: () => (/* binding */ removeRow),\n/* harmony export */   rowIsHeader: () => (/* binding */ rowIsHeader),\n/* harmony export */   selectedRect: () => (/* binding */ selectedRect),\n/* harmony export */   selectionCell: () => (/* binding */ selectionCell),\n/* harmony export */   setCellAttr: () => (/* binding */ setCellAttr),\n/* harmony export */   splitCell: () => (/* binding */ splitCell),\n/* harmony export */   splitCellWithType: () => (/* binding */ splitCellWithType),\n/* harmony export */   tableEditing: () => (/* binding */ tableEditing),\n/* harmony export */   tableEditingKey: () => (/* binding */ tableEditingKey),\n/* harmony export */   tableNodeTypes: () => (/* binding */ tableNodeTypes),\n/* harmony export */   tableNodes: () => (/* binding */ tableNodes),\n/* harmony export */   toggleHeader: () => (/* binding */ toggleHeader),\n/* harmony export */   toggleHeaderCell: () => (/* binding */ toggleHeaderCell),\n/* harmony export */   toggleHeaderColumn: () => (/* binding */ toggleHeaderColumn),\n/* harmony export */   toggleHeaderRow: () => (/* binding */ toggleHeaderRow),\n/* harmony export */   updateColumnsOnResize: () => (/* binding */ updateColumnsOnResize)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// src/index.ts\n\n\n// src/cellselection.ts\n\n\n\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  if (width === 0 || height === 0)\n    (problems || (problems = [])).push({ type: \"zero_sized\" });\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n\n// src/util.ts\n\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction validateColwidth(value) {\n  if (value === null) {\n    return;\n  }\n  if (!Array.isArray(value)) {\n    throw new TypeError(\"colwidth must be null or an array\");\n  }\n  for (const item of value) {\n    if (typeof item !== \"number\") {\n      throw new TypeError(\"colwidth must be null or an array of numbers\");\n    }\n  }\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1, validate: \"number\" },\n    rowspan: { default: 1, validate: \"number\" },\n    colwidth: { default: null, validate: validateColwidth }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = {\n      default: extraAttrs[prop].default,\n      validate: extraAttrs[prop].validate\n    };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\") return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return _CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return _CellSelection.colSelection($anchorCell, $headCell);\n      else return new _CellSelection($anchorCell, $headCell);\n    }\n    return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty : content\n      );\n    }\n    const sel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel) tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && isCellBoundarySelection(sel)) {\n    normalize = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, sel.from);\n  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\n\nvar fixTablesKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    } else if (prob.type == \"zero_sized\") {\n      const pos = tr.mapping.map(tablePos);\n      tr.delete(pos, pos + table.nodeSize);\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\n\n\n\n\n// src/commands.ts\n\n\n\n// src/utils/convert.ts\nfunction convertTableNodeToArrayOfRows(tableNode) {\n  const map = TableMap.get(tableNode);\n  const rows = [];\n  const rowCount = map.height;\n  const colCount2 = map.width;\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = [];\n    for (let colIndex = 0; colIndex < colCount2; colIndex++) {\n      const cellIndex = rowIndex * colCount2 + colIndex;\n      const cellPos = map.map[cellIndex];\n      if (rowIndex > 0) {\n        const topCellIndex = cellIndex - colCount2;\n        const topCellPos = map.map[topCellIndex];\n        if (cellPos === topCellPos) {\n          row.push(null);\n          continue;\n        }\n      }\n      if (colIndex > 0) {\n        const leftCellIndex = cellIndex - 1;\n        const leftCellPos = map.map[leftCellIndex];\n        if (cellPos === leftCellPos) {\n          row.push(null);\n          continue;\n        }\n      }\n      row.push(tableNode.nodeAt(cellPos));\n    }\n    rows.push(row);\n  }\n  return rows;\n}\nfunction convertArrayOfRowsToTableNode(tableNode, arrayOfNodes) {\n  const newRows = [];\n  const map = TableMap.get(tableNode);\n  const rowCount = map.height;\n  const colCount2 = map.width;\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const oldRow = tableNode.child(rowIndex);\n    const newCells = [];\n    for (let colIndex = 0; colIndex < colCount2; colIndex++) {\n      const cell = arrayOfNodes[rowIndex][colIndex];\n      if (!cell) {\n        continue;\n      }\n      const cellPos = map.map[rowIndex * map.width + colIndex];\n      const oldCell = tableNode.nodeAt(cellPos);\n      if (!oldCell) {\n        continue;\n      }\n      const newCell = oldCell.type.createChecked(\n        cell.attrs,\n        cell.content,\n        cell.marks\n      );\n      newCells.push(newCell);\n    }\n    const newRow = oldRow.type.createChecked(\n      oldRow.attrs,\n      newCells,\n      oldRow.marks\n    );\n    newRows.push(newRow);\n  }\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    newRows,\n    tableNode.marks\n  );\n  return newTable;\n}\n\n// src/utils/query.ts\nfunction isCellSelection(value) {\n  return value instanceof CellSelection;\n}\nfunction findTable($pos) {\n  return findParentNode((node) => node.type.spec.tableRole === \"table\", $pos);\n}\nfunction findCellRange(selection, anchorHit, headHit) {\n  var _a, _b;\n  if (anchorHit == null && headHit == null && isCellSelection(selection)) {\n    return [selection.$anchorCell, selection.$headCell];\n  }\n  const anchor = (_a = anchorHit != null ? anchorHit : headHit) != null ? _a : selection.anchor;\n  const head = (_b = headHit != null ? headHit : anchorHit) != null ? _b : selection.head;\n  const doc = selection.$head.doc;\n  const $anchorCell = findCellPos(doc, anchor);\n  const $headCell = findCellPos(doc, head);\n  if ($anchorCell && $headCell && inSameTable($anchorCell, $headCell)) {\n    return [$anchorCell, $headCell];\n  }\n  return null;\n}\nfunction findCellPos(doc, pos) {\n  const $pos = doc.resolve(pos);\n  return cellAround($pos) || cellNear($pos);\n}\nfunction findParentNode(predicate, $pos) {\n  for (let depth = $pos.depth; depth >= 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (predicate(node)) {\n      const pos = depth === 0 ? 0 : $pos.before(depth);\n      const start = $pos.start(depth);\n      return { node, pos, start, depth };\n    }\n  }\n  return null;\n}\n\n// src/utils/get-cells.ts\nfunction getCellsInColumn(columnIndex, selection) {\n  const table = findTable(selection.$from);\n  if (!table) {\n    return;\n  }\n  const map = TableMap.get(table.node);\n  if (columnIndex < 0 || columnIndex > map.width - 1) {\n    return;\n  }\n  const cells = map.cellsInRect({\n    left: columnIndex,\n    right: columnIndex + 1,\n    top: 0,\n    bottom: map.height\n  });\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos);\n    const pos = nodePos + table.start;\n    return { pos, start: pos + 1, node, depth: table.depth + 2 };\n  });\n}\nfunction getCellsInRow(rowIndex, selection) {\n  const table = findTable(selection.$from);\n  if (!table) {\n    return;\n  }\n  const map = TableMap.get(table.node);\n  if (rowIndex < 0 || rowIndex > map.height - 1) {\n    return;\n  }\n  const cells = map.cellsInRect({\n    left: 0,\n    right: map.width,\n    top: rowIndex,\n    bottom: rowIndex + 1\n  });\n  return cells.map((nodePos) => {\n    const node = table.node.nodeAt(nodePos);\n    const pos = nodePos + table.start;\n    return { pos, start: pos + 1, node, depth: table.depth + 2 };\n  });\n}\n\n// src/utils/selection-range.ts\nfunction getSelectionRangeInColumn(tr, startColIndex, endColIndex = startColIndex) {\n  let startIndex = startColIndex;\n  let endIndex = endColIndex;\n  for (let i = startColIndex; i >= 0; i--) {\n    const cells = getCellsInColumn(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  for (let i = startColIndex; i <= endIndex; i++) {\n    const cells = getCellsInColumn(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInColumn(i, tr.selection);\n    if (maybeCells && maybeCells.length > 0) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n  const firstSelectedColumnCells = getCellsInColumn(startIndex, tr.selection);\n  const firstRowCells = getCellsInRow(0, tr.selection);\n  if (!firstSelectedColumnCells || !firstRowCells) {\n    return;\n  }\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos\n  );\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInColumn(i, tr.selection);\n    if (columnCells && columnCells.length > 0) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j].pos === columnCells[0].pos) {\n          headCell = columnCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n  if (!headCell) {\n    return;\n  }\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n}\nfunction getSelectionRangeInRow(tr, startRowIndex, endRowIndex = startRowIndex) {\n  let startIndex = startRowIndex;\n  let endIndex = endRowIndex;\n  for (let i = startRowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  for (let i = startRowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i, tr.selection);\n    if (cells) {\n      cells.forEach((cell) => {\n        const maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n        if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i, tr.selection);\n    if (maybeCells && maybeCells.length > 0) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n  const firstSelectedRowCells = getCellsInRow(startIndex, tr.selection);\n  const firstColumnCells = getCellsInColumn(0, tr.selection);\n  if (!firstSelectedRowCells || !firstColumnCells) {\n    return;\n  }\n  const $anchor = tr.doc.resolve(\n    firstSelectedRowCells[firstSelectedRowCells.length - 1].pos\n  );\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i, tr.selection);\n    if (rowCells && rowCells.length > 0) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j].pos === rowCells[0].pos) {\n          headCell = rowCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n  if (!headCell) {\n    return;\n  }\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n}\n\n// src/utils/move-row-in-array-of-rows.ts\nfunction moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, directionOverride) {\n  const direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;\n  const rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;\n  let target;\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0] - 1;\n  } else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;\n  } else {\n    target = direction === -1 ? indexesTarget[0] : indexesTarget[indexesTarget.length - 1] - positionOffset;\n  }\n  rows.splice(target, 0, ...rowsExtracted);\n  return rows;\n}\n\n// src/utils/transpose.ts\nfunction transpose(array) {\n  return array[0].map((_, i) => {\n    return array.map((column) => column[i]);\n  });\n}\n\n// src/utils/move-column.ts\nfunction moveColumn(moveColParams) {\n  var _a, _b;\n  const { tr, originIndex, targetIndex, select, pos } = moveColParams;\n  const $pos = tr.doc.resolve(pos);\n  const table = findTable($pos);\n  if (!table) return false;\n  const indexesOriginColumn = (_a = getSelectionRangeInColumn(\n    tr,\n    originIndex\n  )) == null ? void 0 : _a.indexes;\n  const indexesTargetColumn = (_b = getSelectionRangeInColumn(\n    tr,\n    targetIndex\n  )) == null ? void 0 : _b.indexes;\n  if (!indexesOriginColumn || !indexesTargetColumn) return false;\n  if (indexesOriginColumn.includes(targetIndex)) return false;\n  const newTable = moveTableColumn(\n    table.node,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    0\n  );\n  tr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n  if (!select) return true;\n  const map = TableMap.get(newTable);\n  const start = table.start;\n  const index = targetIndex;\n  const lastCell = map.positionAt(map.height - 1, index, newTable);\n  const $lastCell = tr.doc.resolve(start + lastCell);\n  const firstCell = map.positionAt(0, index, newTable);\n  const $firstCell = tr.doc.resolve(start + firstCell);\n  tr.setSelection(CellSelection.colSelection($lastCell, $firstCell));\n  return true;\n}\nfunction moveTableColumn(table, indexesOrigin, indexesTarget, direction) {\n  let rows = transpose(convertTableNodeToArrayOfRows(table));\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n  rows = transpose(rows);\n  return convertArrayOfRowsToTableNode(table, rows);\n}\n\n// src/utils/move-row.ts\nfunction moveRow(moveRowParams) {\n  var _a, _b;\n  const { tr, originIndex, targetIndex, select, pos } = moveRowParams;\n  const $pos = tr.doc.resolve(pos);\n  const table = findTable($pos);\n  if (!table) return false;\n  const indexesOriginRow = (_a = getSelectionRangeInRow(tr, originIndex)) == null ? void 0 : _a.indexes;\n  const indexesTargetRow = (_b = getSelectionRangeInRow(tr, targetIndex)) == null ? void 0 : _b.indexes;\n  if (!indexesOriginRow || !indexesTargetRow) return false;\n  if (indexesOriginRow.includes(targetIndex)) return false;\n  const newTable = moveTableRow(\n    table.node,\n    indexesOriginRow,\n    indexesTargetRow,\n    0\n  );\n  tr.replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);\n  if (!select) return true;\n  const map = TableMap.get(newTable);\n  const start = table.start;\n  const index = targetIndex;\n  const lastCell = map.positionAt(index, map.width - 1, newTable);\n  const $lastCell = tr.doc.resolve(start + lastCell);\n  const firstCell = map.positionAt(index, 0, newTable);\n  const $firstCell = tr.doc.resolve(start + firstCell);\n  tr.setSelection(CellSelection.rowSelection($lastCell, $firstCell));\n  return true;\n}\nfunction moveTableRow(table, indexesOrigin, indexesTarget, direction) {\n  let rows = convertTableNodeToArrayOfRows(table);\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n  return convertArrayOfRowsToTableNode(table, rows);\n}\n\n// src/commands.ts\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */ new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\nfunction moveTableRow2(options) {\n  return (state, dispatch) => {\n    const {\n      from: originIndex,\n      to: targetIndex,\n      select = true,\n      pos = state.selection.from\n    } = options;\n    const tr = state.tr;\n    if (moveRow({ tr, originIndex, targetIndex, select, pos })) {\n      dispatch == null ? void 0 : dispatch(tr);\n      return true;\n    }\n    return false;\n  };\n}\nfunction moveTableColumn2(options) {\n  return (state, dispatch) => {\n    const {\n      from: originIndex,\n      to: targetIndex,\n      select = true,\n      pos = state.selection.from\n    } = options;\n    const tr = state.tr;\n    if (moveColumn({ tr, originIndex, targetIndex, select, pos })) {\n      dispatch == null ? void 0 : dispatch(tr);\n      return true;\n    }\n    return false;\n  };\n}\n\n// src/copypaste.ts\n\n\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_4__.keydownHandler)({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($next, 1);\n      else if (dir < 0)\n        newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting) $head = $anchor2;\n      else return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2) return stop();\n    }\n    if ($anchor2) setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\n\n\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, defaultCellMinWidth) {\n    this.node = node;\n    this.defaultCellMinWidth = defaultCellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.table.style.setProperty(\n      \"--default-cell-min-width\",\n      `${defaultCellMinWidth}px`\n    );\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(\n      node,\n      this.colgroup,\n      this.table,\n      this.defaultCellMinWidth\n    );\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row) return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || defaultCellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        const col2 = document.createElement(\"col\");\n        col2.style.width = cssWidth;\n        colgroup.appendChild(col2);\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  defaultCellMinWidth = 100,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        var _a, _b;\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, defaultCellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, lastColumnResizable) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {\n  var _a;\n  if (!view.editable) return false;\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    win.removeEventListener(\"mouseup\", finish);\n    win.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which) return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2) return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        dragged,\n        defaultCellMinWidth\n      );\n    }\n  }\n  displayColumnWidth(\n    view,\n    pluginState.activeHandle,\n    width,\n    defaultCellMinWidth\n  );\n  win.addEventListener(\"mouseup\", finish);\n  win.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == \"right\") return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, resizeMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, defaultCellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    defaultCellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  var _a;\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {\n        decorations.push(\n          prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.node(\n            start + cellPos,\n            start + cellPos + table.nodeAt(cellPos).nodeSize,\n            {\n              class: \"column-resize-dragging\"\n            }\n          )\n        );\n      }\n      decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(pos, dom));\n    }\n  }\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations);\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdGFibGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3NEOztBQUV0RDtBQUNvRDtBQU16QjtBQUNrQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBaUQ7QUFDdkU7QUFDQTtBQUNBLHNCQUFzQixnRUFBZ0U7QUFDdEY7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRCxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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cyI6WyJ3ZWJwYWNrOi8vYWktdmlkZW8tZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRhYmxlcy9kaXN0L2luZGV4LmpzPzA2MDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBQbHVnaW4gYXMgUGx1Z2luMiB9IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuXG4vLyBzcmMvY2VsbHNlbGVjdGlvbi50c1xuaW1wb3J0IHsgRnJhZ21lbnQsIFNsaWNlIH0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQge1xuICBOb2RlU2VsZWN0aW9uIGFzIE5vZGVTZWxlY3Rpb24yLFxuICBTZWxlY3Rpb24sXG4gIFNlbGVjdGlvblJhbmdlLFxuICBUZXh0U2VsZWN0aW9uXG59IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCB9IGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7XG5cbi8vIHNyYy90YWJsZW1hcC50c1xudmFyIHJlYWRGcm9tQ2FjaGU7XG52YXIgYWRkVG9DYWNoZTtcbmlmICh0eXBlb2YgV2Vha01hcCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGxldCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICByZWFkRnJvbUNhY2hlID0gKGtleSkgPT4gY2FjaGUuZ2V0KGtleSk7XG4gIGFkZFRvQ2FjaGUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59IGVsc2Uge1xuICBjb25zdCBjYWNoZSA9IFtdO1xuICBjb25zdCBjYWNoZVNpemUgPSAxMDtcbiAgbGV0IGNhY2hlUG9zID0gMDtcbiAgcmVhZEZyb21DYWNoZSA9IChrZXkpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgaWYgKGNhY2hlW2ldID09IGtleSkgcmV0dXJuIGNhY2hlW2kgKyAxXTtcbiAgfTtcbiAgYWRkVG9DYWNoZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKGNhY2hlUG9zID09IGNhY2hlU2l6ZSkgY2FjaGVQb3MgPSAwO1xuICAgIGNhY2hlW2NhY2hlUG9zKytdID0ga2V5O1xuICAgIHJldHVybiBjYWNoZVtjYWNoZVBvcysrXSA9IHZhbHVlO1xuICB9O1xufVxudmFyIFRhYmxlTWFwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBtYXAsIHByb2JsZW1zKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMucHJvYmxlbXMgPSBwcm9ibGVtcztcbiAgfVxuICAvLyBGaW5kIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgZmluZENlbGwocG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VyUG9zID0gdGhpcy5tYXBbaV07XG4gICAgICBpZiAoY3VyUG9zICE9IHBvcykgY29udGludWU7XG4gICAgICBjb25zdCBsZWZ0ID0gaSAlIHRoaXMud2lkdGg7XG4gICAgICBjb25zdCB0b3AgPSBpIC8gdGhpcy53aWR0aCB8IDA7XG4gICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgIGxldCBib3R0b20gPSB0b3AgKyAxO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IHJpZ2h0IDwgdGhpcy53aWR0aCAmJiB0aGlzLm1hcFtpICsgal0gPT0gY3VyUG9zOyBqKyspIHtcbiAgICAgICAgcmlnaHQrKztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAxOyBib3R0b20gPCB0aGlzLmhlaWdodCAmJiB0aGlzLm1hcFtpICsgdGhpcy53aWR0aCAqIGpdID09IGN1clBvczsgaisrKSB7XG4gICAgICAgIGJvdHRvbSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuICB9XG4gIC8vIEZpbmQgdGhlIGxlZnQgc2lkZSBvZiB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbENvdW50KHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm1hcFtpXSA9PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIGkgJSB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgfVxuICAvLyBGaW5kIHRoZSBuZXh0IGNlbGwgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgY2VsbFxuICAvLyBhdCBgcG9zYCwgaWYgYW55LlxuICBuZXh0Q2VsbChwb3MsIGF4aXMsIGRpcikge1xuICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSB0aGlzLmZpbmRDZWxsKHBvcyk7XG4gICAgaWYgKGF4aXMgPT0gXCJob3JpelwiKSB7XG4gICAgICBpZiAoZGlyIDwgMCA/IGxlZnQgPT0gMCA6IHJpZ2h0ID09IHRoaXMud2lkdGgpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMubWFwW3RvcCAqIHRoaXMud2lkdGggKyAoZGlyIDwgMCA/IGxlZnQgLSAxIDogcmlnaHQpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRpciA8IDAgPyB0b3AgPT0gMCA6IGJvdHRvbSA9PSB0aGlzLmhlaWdodCkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5tYXBbbGVmdCArIHRoaXMud2lkdGggKiAoZGlyIDwgMCA/IHRvcCAtIDEgOiBib3R0b20pXTtcbiAgICB9XG4gIH1cbiAgLy8gR2V0IHRoZSByZWN0YW5nbGUgc3Bhbm5pbmcgdGhlIHR3byBnaXZlbiBjZWxscy5cbiAgcmVjdEJldHdlZW4oYSwgYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IGxlZnRBLFxuICAgICAgcmlnaHQ6IHJpZ2h0QSxcbiAgICAgIHRvcDogdG9wQSxcbiAgICAgIGJvdHRvbTogYm90dG9tQVxuICAgIH0gPSB0aGlzLmZpbmRDZWxsKGEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IGxlZnRCLFxuICAgICAgcmlnaHQ6IHJpZ2h0QixcbiAgICAgIHRvcDogdG9wQixcbiAgICAgIGJvdHRvbTogYm90dG9tQlxuICAgIH0gPSB0aGlzLmZpbmRDZWxsKGIpO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBNYXRoLm1pbihsZWZ0QSwgbGVmdEIpLFxuICAgICAgdG9wOiBNYXRoLm1pbih0b3BBLCB0b3BCKSxcbiAgICAgIHJpZ2h0OiBNYXRoLm1heChyaWdodEEsIHJpZ2h0QiksXG4gICAgICBib3R0b206IE1hdGgubWF4KGJvdHRvbUEsIGJvdHRvbUIpXG4gICAgfTtcbiAgfVxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIGFsbCBjZWxscyB0aGF0IGhhdmUgdGhlIHRvcCBsZWZ0IGNvcm5lciBpblxuICAvLyB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICBjZWxsc0luUmVjdChyZWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgIGZvciAobGV0IHJvdyA9IHJlY3QudG9wOyByb3cgPCByZWN0LmJvdHRvbTsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IHJlY3QubGVmdDsgY29sIDwgcmVjdC5yaWdodDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByb3cgKiB0aGlzLndpZHRoICsgY29sO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLm1hcFtpbmRleF07XG4gICAgICAgIGlmIChzZWVuW3Bvc10pIGNvbnRpbnVlO1xuICAgICAgICBzZWVuW3Bvc10gPSB0cnVlO1xuICAgICAgICBpZiAoY29sID09IHJlY3QubGVmdCAmJiBjb2wgJiYgdGhpcy5tYXBbaW5kZXggLSAxXSA9PSBwb3MgfHwgcm93ID09IHJlY3QudG9wICYmIHJvdyAmJiB0aGlzLm1hcFtpbmRleCAtIHRoaXMud2lkdGhdID09IHBvcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHBvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gcm93IGFuZCBjb2x1bW5cbiAgLy8gc3RhcnRzLCBvciB3b3VsZCBzdGFydCwgaWYgYSBjZWxsIHN0YXJ0ZWQgdGhlcmUuXG4gIHBvc2l0aW9uQXQocm93LCBjb2wsIHRhYmxlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHJvd1N0YXJ0ID0gMDsgOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvd0VuZCA9IHJvd1N0YXJ0ICsgdGFibGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICBpZiAoaSA9PSByb3cpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gY29sICsgcm93ICogdGhpcy53aWR0aDtcbiAgICAgICAgY29uc3Qgcm93RW5kSW5kZXggPSAocm93ICsgMSkgKiB0aGlzLndpZHRoO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCByb3dFbmRJbmRleCAmJiB0aGlzLm1hcFtpbmRleF0gPCByb3dTdGFydCkgaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIGluZGV4ID09IHJvd0VuZEluZGV4ID8gcm93RW5kIC0gMSA6IHRoaXMubWFwW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJvd1N0YXJ0ID0gcm93RW5kO1xuICAgIH1cbiAgfVxuICAvLyBGaW5kIHRoZSB0YWJsZSBtYXAgZm9yIHRoZSBnaXZlbiB0YWJsZSBub2RlLlxuICBzdGF0aWMgZ2V0KHRhYmxlKSB7XG4gICAgcmV0dXJuIHJlYWRGcm9tQ2FjaGUodGFibGUpIHx8IGFkZFRvQ2FjaGUodGFibGUsIGNvbXB1dGVNYXAodGFibGUpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNvbXB1dGVNYXAodGFibGUpIHtcbiAgaWYgKHRhYmxlLnR5cGUuc3BlYy50YWJsZVJvbGUgIT0gXCJ0YWJsZVwiKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm90IGEgdGFibGUgbm9kZTogXCIgKyB0YWJsZS50eXBlLm5hbWUpO1xuICBjb25zdCB3aWR0aCA9IGZpbmRXaWR0aCh0YWJsZSksIGhlaWdodCA9IHRhYmxlLmNoaWxkQ291bnQ7XG4gIGNvbnN0IG1hcCA9IFtdO1xuICBsZXQgbWFwUG9zID0gMDtcbiAgbGV0IHByb2JsZW1zID0gbnVsbDtcbiAgY29uc3QgY29sV2lkdGhzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBlID0gd2lkdGggKiBoZWlnaHQ7IGkgPCBlOyBpKyspIG1hcFtpXSA9IDA7XG4gIGZvciAobGV0IHJvdyA9IDAsIHBvcyA9IDA7IHJvdyA8IGhlaWdodDsgcm93KyspIHtcbiAgICBjb25zdCByb3dOb2RlID0gdGFibGUuY2hpbGQocm93KTtcbiAgICBwb3MrKztcbiAgICBmb3IgKGxldCBpID0gMDsgOyBpKyspIHtcbiAgICAgIHdoaWxlIChtYXBQb3MgPCBtYXAubGVuZ3RoICYmIG1hcFttYXBQb3NdICE9IDApIG1hcFBvcysrO1xuICAgICAgaWYgKGkgPT0gcm93Tm9kZS5jaGlsZENvdW50KSBicmVhaztcbiAgICAgIGNvbnN0IGNlbGxOb2RlID0gcm93Tm9kZS5jaGlsZChpKTtcbiAgICAgIGNvbnN0IHsgY29sc3Bhbiwgcm93c3BhbiwgY29sd2lkdGggfSA9IGNlbGxOb2RlLmF0dHJzO1xuICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCByb3dzcGFuOyBoKyspIHtcbiAgICAgICAgaWYgKGggKyByb3cgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgKHByb2JsZW1zIHx8IChwcm9ibGVtcyA9IFtdKSkucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIm92ZXJsb25nX3Jvd3NwYW5cIixcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIG46IHJvd3NwYW4gLSBoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBtYXBQb3MgKyBoICogd2lkdGg7XG4gICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgY29sc3BhbjsgdysrKSB7XG4gICAgICAgICAgaWYgKG1hcFtzdGFydCArIHddID09IDApIG1hcFtzdGFydCArIHddID0gcG9zO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIChwcm9ibGVtcyB8fCAocHJvYmxlbXMgPSBbXSkpLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcImNvbGxpc2lvblwiLFxuICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgbjogY29sc3BhbiAtIHdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGNvbFcgPSBjb2x3aWR0aCAmJiBjb2x3aWR0aFt3XTtcbiAgICAgICAgICBpZiAoY29sVykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhJbmRleCA9IChzdGFydCArIHcpICUgd2lkdGggKiAyLCBwcmV2ID0gY29sV2lkdGhzW3dpZHRoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCBwcmV2ICE9IGNvbFcgJiYgY29sV2lkdGhzW3dpZHRoSW5kZXggKyAxXSA9PSAxKSB7XG4gICAgICAgICAgICAgIGNvbFdpZHRoc1t3aWR0aEluZGV4XSA9IGNvbFc7XG4gICAgICAgICAgICAgIGNvbFdpZHRoc1t3aWR0aEluZGV4ICsgMV0gPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2ID09IGNvbFcpIHtcbiAgICAgICAgICAgICAgY29sV2lkdGhzW3dpZHRoSW5kZXggKyAxXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWFwUG9zICs9IGNvbHNwYW47XG4gICAgICBwb3MgKz0gY2VsbE5vZGUubm9kZVNpemU7XG4gICAgfVxuICAgIGNvbnN0IGV4cGVjdGVkUG9zID0gKHJvdyArIDEpICogd2lkdGg7XG4gICAgbGV0IG1pc3NpbmcgPSAwO1xuICAgIHdoaWxlIChtYXBQb3MgPCBleHBlY3RlZFBvcykgaWYgKG1hcFttYXBQb3MrK10gPT0gMCkgbWlzc2luZysrO1xuICAgIGlmIChtaXNzaW5nKVxuICAgICAgKHByb2JsZW1zIHx8IChwcm9ibGVtcyA9IFtdKSkucHVzaCh7IHR5cGU6IFwibWlzc2luZ1wiLCByb3csIG46IG1pc3NpbmcgfSk7XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMClcbiAgICAocHJvYmxlbXMgfHwgKHByb2JsZW1zID0gW10pKS5wdXNoKHsgdHlwZTogXCJ6ZXJvX3NpemVkXCIgfSk7XG4gIGNvbnN0IHRhYmxlTWFwID0gbmV3IFRhYmxlTWFwKHdpZHRoLCBoZWlnaHQsIG1hcCwgcHJvYmxlbXMpO1xuICBsZXQgYmFkV2lkdGhzID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyAhYmFkV2lkdGhzICYmIGkgPCBjb2xXaWR0aHMubGVuZ3RoOyBpICs9IDIpXG4gICAgaWYgKGNvbFdpZHRoc1tpXSAhPSBudWxsICYmIGNvbFdpZHRoc1tpICsgMV0gPCBoZWlnaHQpIGJhZFdpZHRocyA9IHRydWU7XG4gIGlmIChiYWRXaWR0aHMpIGZpbmRCYWRDb2xXaWR0aHModGFibGVNYXAsIGNvbFdpZHRocywgdGFibGUpO1xuICByZXR1cm4gdGFibGVNYXA7XG59XG5mdW5jdGlvbiBmaW5kV2lkdGgodGFibGUpIHtcbiAgbGV0IHdpZHRoID0gLTE7XG4gIGxldCBoYXNSb3dTcGFuID0gZmFsc2U7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRhYmxlLmNoaWxkQ291bnQ7IHJvdysrKSB7XG4gICAgY29uc3Qgcm93Tm9kZSA9IHRhYmxlLmNoaWxkKHJvdyk7XG4gICAgbGV0IHJvd1dpZHRoID0gMDtcbiAgICBpZiAoaGFzUm93U3BhbilcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93OyBqKyspIHtcbiAgICAgICAgY29uc3QgcHJldlJvdyA9IHRhYmxlLmNoaWxkKGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZSb3cuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2VsbCA9IHByZXZSb3cuY2hpbGQoaSk7XG4gICAgICAgICAgaWYgKGogKyBjZWxsLmF0dHJzLnJvd3NwYW4gPiByb3cpIHJvd1dpZHRoICs9IGNlbGwuYXR0cnMuY29sc3BhbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Tm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dOb2RlLmNoaWxkKGkpO1xuICAgICAgcm93V2lkdGggKz0gY2VsbC5hdHRycy5jb2xzcGFuO1xuICAgICAgaWYgKGNlbGwuYXR0cnMucm93c3BhbiA+IDEpIGhhc1Jvd1NwYW4gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAod2lkdGggPT0gLTEpIHdpZHRoID0gcm93V2lkdGg7XG4gICAgZWxzZSBpZiAod2lkdGggIT0gcm93V2lkdGgpIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHJvd1dpZHRoKTtcbiAgfVxuICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiBmaW5kQmFkQ29sV2lkdGhzKG1hcCwgY29sV2lkdGhzLCB0YWJsZSkge1xuICBpZiAoIW1hcC5wcm9ibGVtcykgbWFwLnByb2JsZW1zID0gW107XG4gIGNvbnN0IHNlZW4gPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAubWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gbWFwLm1hcFtpXTtcbiAgICBpZiAoc2Vlbltwb3NdKSBjb250aW51ZTtcbiAgICBzZWVuW3Bvc10gPSB0cnVlO1xuICAgIGNvbnN0IG5vZGUgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IG51bGw7XG4gICAgY29uc3QgYXR0cnMgPSBub2RlLmF0dHJzO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXR0cnMuY29sc3BhbjsgaisrKSB7XG4gICAgICBjb25zdCBjb2wgPSAoaSArIGopICUgbWFwLndpZHRoO1xuICAgICAgY29uc3QgY29sV2lkdGggPSBjb2xXaWR0aHNbY29sICogMl07XG4gICAgICBpZiAoY29sV2lkdGggIT0gbnVsbCAmJiAoIWF0dHJzLmNvbHdpZHRoIHx8IGF0dHJzLmNvbHdpZHRoW2pdICE9IGNvbFdpZHRoKSlcbiAgICAgICAgKHVwZGF0ZWQgfHwgKHVwZGF0ZWQgPSBmcmVzaENvbFdpZHRoKGF0dHJzKSkpW2pdID0gY29sV2lkdGg7XG4gICAgfVxuICAgIGlmICh1cGRhdGVkKVxuICAgICAgbWFwLnByb2JsZW1zLnVuc2hpZnQoe1xuICAgICAgICB0eXBlOiBcImNvbHdpZHRoIG1pc21hdGNoXCIsXG4gICAgICAgIHBvcyxcbiAgICAgICAgY29sd2lkdGg6IHVwZGF0ZWRcbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmcmVzaENvbFdpZHRoKGF0dHJzKSB7XG4gIGlmIChhdHRycy5jb2x3aWR0aCkgcmV0dXJuIGF0dHJzLmNvbHdpZHRoLnNsaWNlKCk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmNvbHNwYW47IGkrKykgcmVzdWx0LnB1c2goMCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsLnRzXG5pbXBvcnQgeyBQbHVnaW5LZXkgfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcblxuLy8gc3JjL3NjaGVtYS50c1xuZnVuY3Rpb24gZ2V0Q2VsbEF0dHJzKGRvbSwgZXh0cmFBdHRycykge1xuICBpZiAodHlwZW9mIGRvbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCB3aWR0aEF0dHIgPSBkb20uZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2x3aWR0aFwiKTtcbiAgY29uc3Qgd2lkdGhzID0gd2lkdGhBdHRyICYmIC9eXFxkKygsXFxkKykqJC8udGVzdCh3aWR0aEF0dHIpID8gd2lkdGhBdHRyLnNwbGl0KFwiLFwiKS5tYXAoKHMpID0+IE51bWJlcihzKSkgOiBudWxsO1xuICBjb25zdCBjb2xzcGFuID0gTnVtYmVyKGRvbS5nZXRBdHRyaWJ1dGUoXCJjb2xzcGFuXCIpIHx8IDEpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgY29sc3BhbixcbiAgICByb3dzcGFuOiBOdW1iZXIoZG9tLmdldEF0dHJpYnV0ZShcInJvd3NwYW5cIikgfHwgMSksXG4gICAgY29sd2lkdGg6IHdpZHRocyAmJiB3aWR0aHMubGVuZ3RoID09IGNvbHNwYW4gPyB3aWR0aHMgOiBudWxsXG4gIH07XG4gIGZvciAoY29uc3QgcHJvcCBpbiBleHRyYUF0dHJzKSB7XG4gICAgY29uc3QgZ2V0dGVyID0gZXh0cmFBdHRyc1twcm9wXS5nZXRGcm9tRE9NO1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyICYmIGdldHRlcihkb20pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNldENlbGxBdHRycyhub2RlLCBleHRyYUF0dHJzKSB7XG4gIGNvbnN0IGF0dHJzID0ge307XG4gIGlmIChub2RlLmF0dHJzLmNvbHNwYW4gIT0gMSkgYXR0cnMuY29sc3BhbiA9IG5vZGUuYXR0cnMuY29sc3BhbjtcbiAgaWYgKG5vZGUuYXR0cnMucm93c3BhbiAhPSAxKSBhdHRycy5yb3dzcGFuID0gbm9kZS5hdHRycy5yb3dzcGFuO1xuICBpZiAobm9kZS5hdHRycy5jb2x3aWR0aClcbiAgICBhdHRyc1tcImRhdGEtY29sd2lkdGhcIl0gPSBub2RlLmF0dHJzLmNvbHdpZHRoLmpvaW4oXCIsXCIpO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZXh0cmFBdHRycykge1xuICAgIGNvbnN0IHNldHRlciA9IGV4dHJhQXR0cnNbcHJvcF0uc2V0RE9NQXR0cjtcbiAgICBpZiAoc2V0dGVyKSBzZXR0ZXIobm9kZS5hdHRyc1twcm9wXSwgYXR0cnMpO1xuICB9XG4gIHJldHVybiBhdHRycztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ29sd2lkdGgodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY29sd2lkdGggbXVzdCBiZSBudWxsIG9yIGFuIGFycmF5XCIpO1xuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvbHdpZHRoIG11c3QgYmUgbnVsbCBvciBhbiBhcnJheSBvZiBudW1iZXJzXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFibGVOb2RlcyhvcHRpb25zKSB7XG4gIGNvbnN0IGV4dHJhQXR0cnMgPSBvcHRpb25zLmNlbGxBdHRyaWJ1dGVzIHx8IHt9O1xuICBjb25zdCBjZWxsQXR0cnMgPSB7XG4gICAgY29sc3BhbjogeyBkZWZhdWx0OiAxLCB2YWxpZGF0ZTogXCJudW1iZXJcIiB9LFxuICAgIHJvd3NwYW46IHsgZGVmYXVsdDogMSwgdmFsaWRhdGU6IFwibnVtYmVyXCIgfSxcbiAgICBjb2x3aWR0aDogeyBkZWZhdWx0OiBudWxsLCB2YWxpZGF0ZTogdmFsaWRhdGVDb2x3aWR0aCB9XG4gIH07XG4gIGZvciAoY29uc3QgcHJvcCBpbiBleHRyYUF0dHJzKVxuICAgIGNlbGxBdHRyc1twcm9wXSA9IHtcbiAgICAgIGRlZmF1bHQ6IGV4dHJhQXR0cnNbcHJvcF0uZGVmYXVsdCxcbiAgICAgIHZhbGlkYXRlOiBleHRyYUF0dHJzW3Byb3BdLnZhbGlkYXRlXG4gICAgfTtcbiAgcmV0dXJuIHtcbiAgICB0YWJsZToge1xuICAgICAgY29udGVudDogXCJ0YWJsZV9yb3crXCIsXG4gICAgICB0YWJsZVJvbGU6IFwidGFibGVcIixcbiAgICAgIGlzb2xhdGluZzogdHJ1ZSxcbiAgICAgIGdyb3VwOiBvcHRpb25zLnRhYmxlR3JvdXAsXG4gICAgICBwYXJzZURPTTogW3sgdGFnOiBcInRhYmxlXCIgfV0sXG4gICAgICB0b0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIFtcInRhYmxlXCIsIFtcInRib2R5XCIsIDBdXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlX3Jvdzoge1xuICAgICAgY29udGVudDogXCIodGFibGVfY2VsbCB8IHRhYmxlX2hlYWRlcikqXCIsXG4gICAgICB0YWJsZVJvbGU6IFwicm93XCIsXG4gICAgICBwYXJzZURPTTogW3sgdGFnOiBcInRyXCIgfV0sXG4gICAgICB0b0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIFtcInRyXCIsIDBdO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVfY2VsbDoge1xuICAgICAgY29udGVudDogb3B0aW9ucy5jZWxsQ29udGVudCxcbiAgICAgIGF0dHJzOiBjZWxsQXR0cnMsXG4gICAgICB0YWJsZVJvbGU6IFwiY2VsbFwiLFxuICAgICAgaXNvbGF0aW5nOiB0cnVlLFxuICAgICAgcGFyc2VET006IFtcbiAgICAgICAgeyB0YWc6IFwidGRcIiwgZ2V0QXR0cnM6IChkb20pID0+IGdldENlbGxBdHRycyhkb20sIGV4dHJhQXR0cnMpIH1cbiAgICAgIF0sXG4gICAgICB0b0RPTShub2RlKSB7XG4gICAgICAgIHJldHVybiBbXCJ0ZFwiLCBzZXRDZWxsQXR0cnMobm9kZSwgZXh0cmFBdHRycyksIDBdO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVfaGVhZGVyOiB7XG4gICAgICBjb250ZW50OiBvcHRpb25zLmNlbGxDb250ZW50LFxuICAgICAgYXR0cnM6IGNlbGxBdHRycyxcbiAgICAgIHRhYmxlUm9sZTogXCJoZWFkZXJfY2VsbFwiLFxuICAgICAgaXNvbGF0aW5nOiB0cnVlLFxuICAgICAgcGFyc2VET006IFtcbiAgICAgICAgeyB0YWc6IFwidGhcIiwgZ2V0QXR0cnM6IChkb20pID0+IGdldENlbGxBdHRycyhkb20sIGV4dHJhQXR0cnMpIH1cbiAgICAgIF0sXG4gICAgICB0b0RPTShub2RlKSB7XG4gICAgICAgIHJldHVybiBbXCJ0aFwiLCBzZXRDZWxsQXR0cnMobm9kZSwgZXh0cmFBdHRycyksIDBdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRhYmxlTm9kZVR5cGVzKHNjaGVtYSkge1xuICBsZXQgcmVzdWx0ID0gc2NoZW1hLmNhY2hlZC50YWJsZU5vZGVUeXBlcztcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBzY2hlbWEuY2FjaGVkLnRhYmxlTm9kZVR5cGVzID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNjaGVtYS5ub2Rlcykge1xuICAgICAgY29uc3QgdHlwZSA9IHNjaGVtYS5ub2Rlc1tuYW1lXSwgcm9sZSA9IHR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgICBpZiAocm9sZSkgcmVzdWx0W3JvbGVdID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3V0aWwudHNcbnZhciB0YWJsZUVkaXRpbmdLZXkgPSBuZXcgUGx1Z2luS2V5KFwic2VsZWN0aW5nQ2VsbHNcIik7XG5mdW5jdGlvbiBjZWxsQXJvdW5kKCRwb3MpIHtcbiAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID4gMDsgZC0tKVxuICAgIGlmICgkcG9zLm5vZGUoZCkudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiKVxuICAgICAgcmV0dXJuICRwb3Mubm9kZSgwKS5yZXNvbHZlKCRwb3MuYmVmb3JlKGQgKyAxKSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2VsbFdyYXBwaW5nKCRwb3MpIHtcbiAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPiAwOyBkLS0pIHtcbiAgICBjb25zdCByb2xlID0gJHBvcy5ub2RlKGQpLnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgaWYgKHJvbGUgPT09IFwiY2VsbFwiIHx8IHJvbGUgPT09IFwiaGVhZGVyX2NlbGxcIikgcmV0dXJuICRwb3Mubm9kZShkKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzSW5UYWJsZShzdGF0ZSkge1xuICBjb25zdCAkaGVhZCA9IHN0YXRlLnNlbGVjdGlvbi4kaGVhZDtcbiAgZm9yIChsZXQgZCA9ICRoZWFkLmRlcHRoOyBkID4gMDsgZC0tKVxuICAgIGlmICgkaGVhZC5ub2RlKGQpLnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJyb3dcIikgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkNlbGwoc3RhdGUpIHtcbiAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoXCIkYW5jaG9yQ2VsbFwiIGluIHNlbCAmJiBzZWwuJGFuY2hvckNlbGwpIHtcbiAgICByZXR1cm4gc2VsLiRhbmNob3JDZWxsLnBvcyA+IHNlbC4kaGVhZENlbGwucG9zID8gc2VsLiRhbmNob3JDZWxsIDogc2VsLiRoZWFkQ2VsbDtcbiAgfSBlbHNlIGlmIChcIm5vZGVcIiBpbiBzZWwgJiYgc2VsLm5vZGUgJiYgc2VsLm5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcImNlbGxcIikge1xuICAgIHJldHVybiBzZWwuJGFuY2hvcjtcbiAgfVxuICBjb25zdCAkY2VsbCA9IGNlbGxBcm91bmQoc2VsLiRoZWFkKSB8fCBjZWxsTmVhcihzZWwuJGhlYWQpO1xuICBpZiAoJGNlbGwpIHtcbiAgICByZXR1cm4gJGNlbGw7XG4gIH1cbiAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIGNlbGwgZm91bmQgYXJvdW5kIHBvc2l0aW9uICR7c2VsLmhlYWR9YCk7XG59XG5mdW5jdGlvbiBjZWxsTmVhcigkcG9zKSB7XG4gIGZvciAobGV0IGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXIsIHBvcyA9ICRwb3MucG9zOyBhZnRlcjsgYWZ0ZXIgPSBhZnRlci5maXJzdENoaWxkLCBwb3MrKykge1xuICAgIGNvbnN0IHJvbGUgPSBhZnRlci50eXBlLnNwZWMudGFibGVSb2xlO1xuICAgIGlmIChyb2xlID09IFwiY2VsbFwiIHx8IHJvbGUgPT0gXCJoZWFkZXJfY2VsbFwiKSByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICB9XG4gIGZvciAobGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgcG9zID0gJHBvcy5wb3M7IGJlZm9yZTsgYmVmb3JlID0gYmVmb3JlLmxhc3RDaGlsZCwgcG9zLS0pIHtcbiAgICBjb25zdCByb2xlID0gYmVmb3JlLnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpXG4gICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZShwb3MgLSBiZWZvcmUubm9kZVNpemUpO1xuICB9XG59XG5mdW5jdGlvbiBwb2ludHNBdENlbGwoJHBvcykge1xuICByZXR1cm4gJHBvcy5wYXJlbnQudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInJvd1wiICYmICEhJHBvcy5ub2RlQWZ0ZXI7XG59XG5mdW5jdGlvbiBtb3ZlQ2VsbEZvcndhcmQoJHBvcykge1xuICByZXR1cm4gJHBvcy5ub2RlKDApLnJlc29sdmUoJHBvcy5wb3MgKyAkcG9zLm5vZGVBZnRlci5ub2RlU2l6ZSk7XG59XG5mdW5jdGlvbiBpblNhbWVUYWJsZSgkY2VsbEEsICRjZWxsQikge1xuICByZXR1cm4gJGNlbGxBLmRlcHRoID09ICRjZWxsQi5kZXB0aCAmJiAkY2VsbEEucG9zID49ICRjZWxsQi5zdGFydCgtMSkgJiYgJGNlbGxBLnBvcyA8PSAkY2VsbEIuZW5kKC0xKTtcbn1cbmZ1bmN0aW9uIGZpbmRDZWxsKCRwb3MpIHtcbiAgcmV0dXJuIFRhYmxlTWFwLmdldCgkcG9zLm5vZGUoLTEpKS5maW5kQ2VsbCgkcG9zLnBvcyAtICRwb3Muc3RhcnQoLTEpKTtcbn1cbmZ1bmN0aW9uIGNvbENvdW50KCRwb3MpIHtcbiAgcmV0dXJuIFRhYmxlTWFwLmdldCgkcG9zLm5vZGUoLTEpKS5jb2xDb3VudCgkcG9zLnBvcyAtICRwb3Muc3RhcnQoLTEpKTtcbn1cbmZ1bmN0aW9uIG5leHRDZWxsKCRwb3MsIGF4aXMsIGRpcikge1xuICBjb25zdCB0YWJsZSA9ICRwb3Mubm9kZSgtMSk7XG4gIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gIGNvbnN0IHRhYmxlU3RhcnQgPSAkcG9zLnN0YXJ0KC0xKTtcbiAgY29uc3QgbW92ZWQgPSBtYXAubmV4dENlbGwoJHBvcy5wb3MgLSB0YWJsZVN0YXJ0LCBheGlzLCBkaXIpO1xuICByZXR1cm4gbW92ZWQgPT0gbnVsbCA/IG51bGwgOiAkcG9zLm5vZGUoMCkucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbW92ZWQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ29sU3BhbihhdHRycywgcG9zLCBuID0gMSkge1xuICBjb25zdCByZXN1bHQgPSB7IC4uLmF0dHJzLCBjb2xzcGFuOiBhdHRycy5jb2xzcGFuIC0gbiB9O1xuICBpZiAocmVzdWx0LmNvbHdpZHRoKSB7XG4gICAgcmVzdWx0LmNvbHdpZHRoID0gcmVzdWx0LmNvbHdpZHRoLnNsaWNlKCk7XG4gICAgcmVzdWx0LmNvbHdpZHRoLnNwbGljZShwb3MsIG4pO1xuICAgIGlmICghcmVzdWx0LmNvbHdpZHRoLnNvbWUoKHcpID0+IHcgPiAwKSkgcmVzdWx0LmNvbHdpZHRoID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYWRkQ29sU3BhbihhdHRycywgcG9zLCBuID0gMSkge1xuICBjb25zdCByZXN1bHQgPSB7IC4uLmF0dHJzLCBjb2xzcGFuOiBhdHRycy5jb2xzcGFuICsgbiB9O1xuICBpZiAocmVzdWx0LmNvbHdpZHRoKSB7XG4gICAgcmVzdWx0LmNvbHdpZHRoID0gcmVzdWx0LmNvbHdpZHRoLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHJlc3VsdC5jb2x3aWR0aC5zcGxpY2UocG9zLCAwLCAwKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29sdW1uSXNIZWFkZXIobWFwLCB0YWJsZSwgY29sKSB7XG4gIGNvbnN0IGhlYWRlckNlbGwgPSB0YWJsZU5vZGVUeXBlcyh0YWJsZS50eXBlLnNjaGVtYSkuaGVhZGVyX2NlbGw7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7IHJvdysrKVxuICAgIGlmICh0YWJsZS5ub2RlQXQobWFwLm1hcFtjb2wgKyByb3cgKiBtYXAud2lkdGhdKS50eXBlICE9IGhlYWRlckNlbGwpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvY2VsbHNlbGVjdGlvbi50c1xudmFyIENlbGxTZWxlY3Rpb24gPSBjbGFzcyBfQ2VsbFNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gIC8vIEEgdGFibGUgc2VsZWN0aW9uIGlzIGlkZW50aWZpZWQgYnkgaXRzIGFuY2hvciBhbmQgaGVhZCBjZWxscy4gVGhlXG4gIC8vIHBvc2l0aW9ucyBnaXZlbiB0byB0aGlzIGNvbnN0cnVjdG9yIHNob3VsZCBwb2ludCBfYmVmb3JlXyB0d29cbiAgLy8gY2VsbHMgaW4gdGhlIHNhbWUgdGFibGUuIFRoZXkgbWF5IGJlIHRoZSBzYW1lLCB0byBzZWxlY3QgYSBzaW5nbGVcbiAgLy8gY2VsbC5cbiAgY29uc3RydWN0b3IoJGFuY2hvckNlbGwsICRoZWFkQ2VsbCA9ICRhbmNob3JDZWxsKSB7XG4gICAgY29uc3QgdGFibGUgPSAkYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIGNvbnN0IHRhYmxlU3RhcnQgPSAkYW5jaG9yQ2VsbC5zdGFydCgtMSk7XG4gICAgY29uc3QgcmVjdCA9IG1hcC5yZWN0QmV0d2VlbihcbiAgICAgICRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQsXG4gICAgICAkaGVhZENlbGwucG9zIC0gdGFibGVTdGFydFxuICAgICk7XG4gICAgY29uc3QgZG9jID0gJGFuY2hvckNlbGwubm9kZSgwKTtcbiAgICBjb25zdCBjZWxscyA9IG1hcC5jZWxsc0luUmVjdChyZWN0KS5maWx0ZXIoKHApID0+IHAgIT0gJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNlbGxzLnVuc2hpZnQoJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNvbnN0IHJhbmdlcyA9IGNlbGxzLm1hcCgocG9zKSA9PiB7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyb20gPSB0YWJsZVN0YXJ0ICsgcG9zICsgMTtcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uUmFuZ2UoXG4gICAgICAgIGRvYy5yZXNvbHZlKGZyb20pLFxuICAgICAgICBkb2MucmVzb2x2ZShmcm9tICsgY2VsbC5jb250ZW50LnNpemUpXG4gICAgICApO1xuICAgIH0pO1xuICAgIHN1cGVyKHJhbmdlc1swXS4kZnJvbSwgcmFuZ2VzWzBdLiR0bywgcmFuZ2VzKTtcbiAgICB0aGlzLiRhbmNob3JDZWxsID0gJGFuY2hvckNlbGw7XG4gICAgdGhpcy4kaGVhZENlbGwgPSAkaGVhZENlbGw7XG4gIH1cbiAgbWFwKGRvYywgbWFwcGluZykge1xuICAgIGNvbnN0ICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy4kYW5jaG9yQ2VsbC5wb3MpKTtcbiAgICBjb25zdCAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLiRoZWFkQ2VsbC5wb3MpKTtcbiAgICBpZiAocG9pbnRzQXRDZWxsKCRhbmNob3JDZWxsKSAmJiBwb2ludHNBdENlbGwoJGhlYWRDZWxsKSAmJiBpblNhbWVUYWJsZSgkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKSkge1xuICAgICAgY29uc3QgdGFibGVDaGFuZ2VkID0gdGhpcy4kYW5jaG9yQ2VsbC5ub2RlKC0xKSAhPSAkYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICAgIGlmICh0YWJsZUNoYW5nZWQgJiYgdGhpcy5pc1Jvd1NlbGVjdGlvbigpKVxuICAgICAgICByZXR1cm4gX0NlbGxTZWxlY3Rpb24ucm93U2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICAgICAgZWxzZSBpZiAodGFibGVDaGFuZ2VkICYmIHRoaXMuaXNDb2xTZWxlY3Rpb24oKSlcbiAgICAgICAgcmV0dXJuIF9DZWxsU2VsZWN0aW9uLmNvbFNlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcbiAgICAgIGVsc2UgcmV0dXJuIG5ldyBfQ2VsbFNlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcbiAgfVxuICAvLyBSZXR1cm5zIGEgcmVjdGFuZ3VsYXIgc2xpY2Ugb2YgdGFibGUgcm93cyBjb250YWluaW5nIHRoZSBzZWxlY3RlZFxuICAvLyBjZWxscy5cbiAgY29udGVudCgpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBjb25zdCB0YWJsZVN0YXJ0ID0gdGhpcy4kYW5jaG9yQ2VsbC5zdGFydCgtMSk7XG4gICAgY29uc3QgcmVjdCA9IG1hcC5yZWN0QmV0d2VlbihcbiAgICAgIHRoaXMuJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCxcbiAgICAgIHRoaXMuJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnRcbiAgICApO1xuICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICBjb25zdCByb3dzID0gW107XG4gICAgZm9yIChsZXQgcm93ID0gcmVjdC50b3A7IHJvdyA8IHJlY3QuYm90dG9tOyByb3crKykge1xuICAgICAgY29uc3Qgcm93Q29udGVudCA9IFtdO1xuICAgICAgZm9yIChsZXQgaW5kZXggPSByb3cgKiBtYXAud2lkdGggKyByZWN0LmxlZnQsIGNvbCA9IHJlY3QubGVmdDsgY29sIDwgcmVjdC5yaWdodDsgY29sKyssIGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgcG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgICAgIGlmIChzZWVuW3Bvc10pIGNvbnRpbnVlO1xuICAgICAgICBzZWVuW3Bvc10gPSB0cnVlO1xuICAgICAgICBjb25zdCBjZWxsUmVjdCA9IG1hcC5maW5kQ2VsbChwb3MpO1xuICAgICAgICBsZXQgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKGBObyBjZWxsIHdpdGggb2Zmc2V0ICR7cG9zfSBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dHJhTGVmdCA9IHJlY3QubGVmdCAtIGNlbGxSZWN0LmxlZnQ7XG4gICAgICAgIGNvbnN0IGV4dHJhUmlnaHQgPSBjZWxsUmVjdC5yaWdodCAtIHJlY3QucmlnaHQ7XG4gICAgICAgIGlmIChleHRyYUxlZnQgPiAwIHx8IGV4dHJhUmlnaHQgPiAwKSB7XG4gICAgICAgICAgbGV0IGF0dHJzID0gY2VsbC5hdHRycztcbiAgICAgICAgICBpZiAoZXh0cmFMZWZ0ID4gMCkge1xuICAgICAgICAgICAgYXR0cnMgPSByZW1vdmVDb2xTcGFuKGF0dHJzLCAwLCBleHRyYUxlZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmFSaWdodCA+IDApIHtcbiAgICAgICAgICAgIGF0dHJzID0gcmVtb3ZlQ29sU3BhbihcbiAgICAgICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgICAgIGF0dHJzLmNvbHNwYW4gLSBleHRyYVJpZ2h0LFxuICAgICAgICAgICAgICBleHRyYVJpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2VsbFJlY3QubGVmdCA8IHJlY3QubGVmdCkge1xuICAgICAgICAgICAgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGVBbmRGaWxsKGF0dHJzKTtcbiAgICAgICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgICAgIGBDb3VsZCBub3QgY3JlYXRlIGNlbGwgd2l0aCBhdHRycyAke0pTT04uc3RyaW5naWZ5KGF0dHJzKX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlKGF0dHJzLCBjZWxsLmNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbFJlY3QudG9wIDwgcmVjdC50b3AgfHwgY2VsbFJlY3QuYm90dG9tID4gcmVjdC5ib3R0b20pIHtcbiAgICAgICAgICBjb25zdCBhdHRycyA9IHtcbiAgICAgICAgICAgIC4uLmNlbGwuYXR0cnMsXG4gICAgICAgICAgICByb3dzcGFuOiBNYXRoLm1pbihjZWxsUmVjdC5ib3R0b20sIHJlY3QuYm90dG9tKSAtIE1hdGgubWF4KGNlbGxSZWN0LnRvcCwgcmVjdC50b3ApXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoY2VsbFJlY3QudG9wIDwgcmVjdC50b3ApIHtcbiAgICAgICAgICAgIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlQW5kRmlsbChhdHRycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlKGF0dHJzLCBjZWxsLmNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByb3dDb250ZW50LnB1c2goY2VsbCk7XG4gICAgICB9XG4gICAgICByb3dzLnB1c2godGFibGUuY2hpbGQocm93KS5jb3B5KEZyYWdtZW50LmZyb20ocm93Q29udGVudCkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmlzQ29sU2VsZWN0aW9uKCkgJiYgdGhpcy5pc1Jvd1NlbGVjdGlvbigpID8gdGFibGUgOiByb3dzO1xuICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShmcmFnbWVudCksIDEsIDEpO1xuICB9XG4gIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgIGNvbnN0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICB0ci5yZXBsYWNlKFxuICAgICAgICBtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLFxuICAgICAgICBtYXBwaW5nLm1hcCgkdG8ucG9zKSxcbiAgICAgICAgaSA/IFNsaWNlLmVtcHR5IDogY29udGVudFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsID0gU2VsZWN0aW9uLmZpbmRGcm9tKFxuICAgICAgdHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAodGhpcy50bykpLFxuICAgICAgLTFcbiAgICApO1xuICAgIGlmIChzZWwpIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICB9XG4gIHJlcGxhY2VXaXRoKHRyLCBub2RlKSB7XG4gICAgdGhpcy5yZXBsYWNlKHRyLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlKSwgMCwgMCkpO1xuICB9XG4gIGZvckVhY2hDZWxsKGYpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBjb25zdCB0YWJsZVN0YXJ0ID0gdGhpcy4kYW5jaG9yQ2VsbC5zdGFydCgtMSk7XG4gICAgY29uc3QgY2VsbHMgPSBtYXAuY2VsbHNJblJlY3QoXG4gICAgICBtYXAucmVjdEJldHdlZW4oXG4gICAgICAgIHRoaXMuJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCxcbiAgICAgICAgdGhpcy4kaGVhZENlbGwucG9zIC0gdGFibGVTdGFydFxuICAgICAgKVxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgZih0YWJsZS5ub2RlQXQoY2VsbHNbaV0pLCB0YWJsZVN0YXJ0ICsgY2VsbHNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBUcnVlIGlmIHRoaXMgc2VsZWN0aW9uIGdvZXMgYWxsIHRoZSB3YXkgZnJvbSB0aGUgdG9wIHRvIHRoZVxuICAvLyBib3R0b20gb2YgdGhlIHRhYmxlLlxuICBpc0NvbFNlbGVjdGlvbigpIHtcbiAgICBjb25zdCBhbmNob3JUb3AgPSB0aGlzLiRhbmNob3JDZWxsLmluZGV4KC0xKTtcbiAgICBjb25zdCBoZWFkVG9wID0gdGhpcy4kaGVhZENlbGwuaW5kZXgoLTEpO1xuICAgIGlmIChNYXRoLm1pbihhbmNob3JUb3AsIGhlYWRUb3ApID4gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFuY2hvckJvdHRvbSA9IGFuY2hvclRvcCArIHRoaXMuJGFuY2hvckNlbGwubm9kZUFmdGVyLmF0dHJzLnJvd3NwYW47XG4gICAgY29uc3QgaGVhZEJvdHRvbSA9IGhlYWRUb3AgKyB0aGlzLiRoZWFkQ2VsbC5ub2RlQWZ0ZXIuYXR0cnMucm93c3BhbjtcbiAgICByZXR1cm4gTWF0aC5tYXgoYW5jaG9yQm90dG9tLCBoZWFkQm90dG9tKSA9PSB0aGlzLiRoZWFkQ2VsbC5ub2RlKC0xKS5jaGlsZENvdW50O1xuICB9XG4gIC8vIFJldHVybnMgdGhlIHNtYWxsZXN0IGNvbHVtbiBzZWxlY3Rpb24gdGhhdCBjb3ZlcnMgdGhlIGdpdmVuIGFuY2hvclxuICAvLyBhbmQgaGVhZCBjZWxsLlxuICBzdGF0aWMgY29sU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwgPSAkYW5jaG9yQ2VsbCkge1xuICAgIGNvbnN0IHRhYmxlID0gJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBjb25zdCB0YWJsZVN0YXJ0ID0gJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IGFuY2hvclJlY3QgPSBtYXAuZmluZENlbGwoJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY29uc3QgaGVhZFJlY3QgPSBtYXAuZmluZENlbGwoJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNvbnN0IGRvYyA9ICRhbmNob3JDZWxsLm5vZGUoMCk7XG4gICAgaWYgKGFuY2hvclJlY3QudG9wIDw9IGhlYWRSZWN0LnRvcCkge1xuICAgICAgaWYgKGFuY2hvclJlY3QudG9wID4gMClcbiAgICAgICAgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLm1hcFthbmNob3JSZWN0LmxlZnRdKTtcbiAgICAgIGlmIChoZWFkUmVjdC5ib3R0b20gPCBtYXAuaGVpZ2h0KVxuICAgICAgICAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZShcbiAgICAgICAgICB0YWJsZVN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiAobWFwLmhlaWdodCAtIDEpICsgaGVhZFJlY3QucmlnaHQgLSAxXVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGVhZFJlY3QudG9wID4gMClcbiAgICAgICAgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5tYXBbaGVhZFJlY3QubGVmdF0pO1xuICAgICAgaWYgKGFuY2hvclJlY3QuYm90dG9tIDwgbWFwLmhlaWdodClcbiAgICAgICAgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZShcbiAgICAgICAgICB0YWJsZVN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiAobWFwLmhlaWdodCAtIDEpICsgYW5jaG9yUmVjdC5yaWdodCAtIDFdXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0NlbGxTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gIH1cbiAgLy8gVHJ1ZSBpZiB0aGlzIHNlbGVjdGlvbiBnb2VzIGFsbCB0aGUgd2F5IGZyb20gdGhlIGxlZnQgdG8gdGhlXG4gIC8vIHJpZ2h0IG9mIHRoZSB0YWJsZS5cbiAgaXNSb3dTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLiRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9IHRoaXMuJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IGFuY2hvckxlZnQgPSBtYXAuY29sQ291bnQodGhpcy4kYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjb25zdCBoZWFkTGVmdCA9IG1hcC5jb2xDb3VudCh0aGlzLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBpZiAoTWF0aC5taW4oYW5jaG9yTGVmdCwgaGVhZExlZnQpID4gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFuY2hvclJpZ2h0ID0gYW5jaG9yTGVmdCArIHRoaXMuJGFuY2hvckNlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW47XG4gICAgY29uc3QgaGVhZFJpZ2h0ID0gaGVhZExlZnQgKyB0aGlzLiRoZWFkQ2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3BhbjtcbiAgICByZXR1cm4gTWF0aC5tYXgoYW5jaG9yUmlnaHQsIGhlYWRSaWdodCkgPT0gbWFwLndpZHRoO1xuICB9XG4gIGVxKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgX0NlbGxTZWxlY3Rpb24gJiYgb3RoZXIuJGFuY2hvckNlbGwucG9zID09IHRoaXMuJGFuY2hvckNlbGwucG9zICYmIG90aGVyLiRoZWFkQ2VsbC5wb3MgPT0gdGhpcy4kaGVhZENlbGwucG9zO1xuICB9XG4gIC8vIFJldHVybnMgdGhlIHNtYWxsZXN0IHJvdyBzZWxlY3Rpb24gdGhhdCBjb3ZlcnMgdGhlIGdpdmVuIGFuY2hvclxuICAvLyBhbmQgaGVhZCBjZWxsLlxuICBzdGF0aWMgcm93U2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwgPSAkYW5jaG9yQ2VsbCkge1xuICAgIGNvbnN0IHRhYmxlID0gJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBjb25zdCB0YWJsZVN0YXJ0ID0gJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IGFuY2hvclJlY3QgPSBtYXAuZmluZENlbGwoJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY29uc3QgaGVhZFJlY3QgPSBtYXAuZmluZENlbGwoJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNvbnN0IGRvYyA9ICRhbmNob3JDZWxsLm5vZGUoMCk7XG4gICAgaWYgKGFuY2hvclJlY3QubGVmdCA8PSBoZWFkUmVjdC5sZWZ0KSB7XG4gICAgICBpZiAoYW5jaG9yUmVjdC5sZWZ0ID4gMClcbiAgICAgICAgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZShcbiAgICAgICAgICB0YWJsZVN0YXJ0ICsgbWFwLm1hcFthbmNob3JSZWN0LnRvcCAqIG1hcC53aWR0aF1cbiAgICAgICAgKTtcbiAgICAgIGlmIChoZWFkUmVjdC5yaWdodCA8IG1hcC53aWR0aClcbiAgICAgICAgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUoXG4gICAgICAgICAgdGFibGVTdGFydCArIG1hcC5tYXBbbWFwLndpZHRoICogKGhlYWRSZWN0LnRvcCArIDEpIC0gMV1cbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhlYWRSZWN0LmxlZnQgPiAwKVxuICAgICAgICAkaGVhZENlbGwgPSBkb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLm1hcFtoZWFkUmVjdC50b3AgKiBtYXAud2lkdGhdKTtcbiAgICAgIGlmIChhbmNob3JSZWN0LnJpZ2h0IDwgbWFwLndpZHRoKVxuICAgICAgICAkYW5jaG9yQ2VsbCA9IGRvYy5yZXNvbHZlKFxuICAgICAgICAgIHRhYmxlU3RhcnQgKyBtYXAubWFwW21hcC53aWR0aCAqIChhbmNob3JSZWN0LnRvcCArIDEpIC0gMV1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ2VsbFNlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgYW5jaG9yOiB0aGlzLiRhbmNob3JDZWxsLnBvcyxcbiAgICAgIGhlYWQ6IHRoaXMuJGhlYWRDZWxsLnBvc1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgIHJldHVybiBuZXcgX0NlbGxTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpLCBkb2MucmVzb2x2ZShqc29uLmhlYWQpKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGRvYywgYW5jaG9yQ2VsbCwgaGVhZENlbGwgPSBhbmNob3JDZWxsKSB7XG4gICAgcmV0dXJuIG5ldyBfQ2VsbFNlbGVjdGlvbihkb2MucmVzb2x2ZShhbmNob3JDZWxsKSwgZG9jLnJlc29sdmUoaGVhZENlbGwpKTtcbiAgfVxuICBnZXRCb29rbWFyaygpIHtcbiAgICByZXR1cm4gbmV3IENlbGxCb29rbWFyayh0aGlzLiRhbmNob3JDZWxsLnBvcywgdGhpcy4kaGVhZENlbGwucG9zKTtcbiAgfVxufTtcbkNlbGxTZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcblNlbGVjdGlvbi5qc29uSUQoXCJjZWxsXCIsIENlbGxTZWxlY3Rpb24pO1xudmFyIENlbGxCb29rbWFyayA9IGNsYXNzIF9DZWxsQm9va21hcmsge1xuICBjb25zdHJ1Y3RvcihhbmNob3IsIGhlYWQpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICB9XG4gIG1hcChtYXBwaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBfQ2VsbEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMuYW5jaG9yKSwgbWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gIH1cbiAgcmVzb2x2ZShkb2MpIHtcbiAgICBjb25zdCAkYW5jaG9yQ2VsbCA9IGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUodGhpcy5oZWFkKTtcbiAgICBpZiAoJGFuY2hvckNlbGwucGFyZW50LnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJyb3dcIiAmJiAkaGVhZENlbGwucGFyZW50LnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJyb3dcIiAmJiAkYW5jaG9yQ2VsbC5pbmRleCgpIDwgJGFuY2hvckNlbGwucGFyZW50LmNoaWxkQ291bnQgJiYgJGhlYWRDZWxsLmluZGV4KCkgPCAkaGVhZENlbGwucGFyZW50LmNoaWxkQ291bnQgJiYgaW5TYW1lVGFibGUoJGFuY2hvckNlbGwsICRoZWFkQ2VsbCkpXG4gICAgICByZXR1cm4gbmV3IENlbGxTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gICAgZWxzZSByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWRDZWxsLCAxKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRyYXdDZWxsU2VsZWN0aW9uKHN0YXRlKSB7XG4gIGlmICghKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2VsbHMgPSBbXTtcbiAgc3RhdGUuc2VsZWN0aW9uLmZvckVhY2hDZWxsKChub2RlLCBwb3MpID0+IHtcbiAgICBjZWxscy5wdXNoKFxuICAgICAgRGVjb3JhdGlvbi5ub2RlKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgeyBjbGFzczogXCJzZWxlY3RlZENlbGxcIiB9KVxuICAgICk7XG4gIH0pO1xuICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBjZWxscyk7XG59XG5mdW5jdGlvbiBpc0NlbGxCb3VuZGFyeVNlbGVjdGlvbih7ICRmcm9tLCAkdG8gfSkge1xuICBpZiAoJGZyb20ucG9zID09ICR0by5wb3MgfHwgJGZyb20ucG9zIDwgJHRvLnBvcyAtIDYpIHJldHVybiBmYWxzZTtcbiAgbGV0IGFmdGVyRnJvbSA9ICRmcm9tLnBvcztcbiAgbGV0IGJlZm9yZVRvID0gJHRvLnBvcztcbiAgbGV0IGRlcHRoID0gJGZyb20uZGVwdGg7XG4gIGZvciAoOyBkZXB0aCA+PSAwOyBkZXB0aC0tLCBhZnRlckZyb20rKylcbiAgICBpZiAoJGZyb20uYWZ0ZXIoZGVwdGggKyAxKSA8ICRmcm9tLmVuZChkZXB0aCkpIGJyZWFrO1xuICBmb3IgKGxldCBkID0gJHRvLmRlcHRoOyBkID49IDA7IGQtLSwgYmVmb3JlVG8tLSlcbiAgICBpZiAoJHRvLmJlZm9yZShkICsgMSkgPiAkdG8uc3RhcnQoZCkpIGJyZWFrO1xuICByZXR1cm4gYWZ0ZXJGcm9tID09IGJlZm9yZVRvICYmIC9yb3d8dGFibGUvLnRlc3QoJGZyb20ubm9kZShkZXB0aCkudHlwZS5zcGVjLnRhYmxlUm9sZSk7XG59XG5mdW5jdGlvbiBpc1RleHRTZWxlY3Rpb25BY3Jvc3NDZWxscyh7ICRmcm9tLCAkdG8gfSkge1xuICBsZXQgZnJvbUNlbGxCb3VuZGFyeU5vZGU7XG4gIGxldCB0b0NlbGxCb3VuZGFyeU5vZGU7XG4gIGZvciAobGV0IGkgPSAkZnJvbS5kZXB0aDsgaSA+IDA7IGktLSkge1xuICAgIGNvbnN0IG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgIGlmIChub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT09IFwiY2VsbFwiIHx8IG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PT0gXCJoZWFkZXJfY2VsbFwiKSB7XG4gICAgICBmcm9tQ2VsbEJvdW5kYXJ5Tm9kZSA9IG5vZGU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9ICR0by5kZXB0aDsgaSA+IDA7IGktLSkge1xuICAgIGNvbnN0IG5vZGUgPSAkdG8ubm9kZShpKTtcbiAgICBpZiAobm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcImNlbGxcIiB8fCBub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT09IFwiaGVhZGVyX2NlbGxcIikge1xuICAgICAgdG9DZWxsQm91bmRhcnlOb2RlID0gbm9kZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUNlbGxCb3VuZGFyeU5vZGUgIT09IHRvQ2VsbEJvdW5kYXJ5Tm9kZSAmJiAkdG8ucGFyZW50T2Zmc2V0ID09PSAwO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHN0YXRlLCB0ciwgYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb24pIHtcbiAgY29uc3Qgc2VsID0gKHRyIHx8IHN0YXRlKS5zZWxlY3Rpb247XG4gIGNvbnN0IGRvYyA9ICh0ciB8fCBzdGF0ZSkuZG9jO1xuICBsZXQgbm9ybWFsaXplO1xuICBsZXQgcm9sZTtcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24yICYmIChyb2xlID0gc2VsLm5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSkpIHtcbiAgICBpZiAocm9sZSA9PSBcImNlbGxcIiB8fCByb2xlID09IFwiaGVhZGVyX2NlbGxcIikge1xuICAgICAgbm9ybWFsaXplID0gQ2VsbFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBzZWwuZnJvbSk7XG4gICAgfSBlbHNlIGlmIChyb2xlID09IFwicm93XCIpIHtcbiAgICAgIGNvbnN0ICRjZWxsID0gZG9jLnJlc29sdmUoc2VsLmZyb20gKyAxKTtcbiAgICAgIG5vcm1hbGl6ZSA9IENlbGxTZWxlY3Rpb24ucm93U2VsZWN0aW9uKCRjZWxsLCAkY2VsbCk7XG4gICAgfSBlbHNlIGlmICghYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldChzZWwubm9kZSk7XG4gICAgICBjb25zdCBzdGFydCA9IHNlbC5mcm9tICsgMTtcbiAgICAgIGNvbnN0IGxhc3RDZWxsID0gc3RhcnQgKyBtYXAubWFwW21hcC53aWR0aCAqIG1hcC5oZWlnaHQgLSAxXTtcbiAgICAgIG5vcm1hbGl6ZSA9IENlbGxTZWxlY3Rpb24uY3JlYXRlKGRvYywgc3RhcnQgKyAxLCBsYXN0Q2VsbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgaXNDZWxsQm91bmRhcnlTZWxlY3Rpb24oc2VsKSkge1xuICAgIG5vcm1hbGl6ZSA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgc2VsLmZyb20pO1xuICB9IGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgaXNUZXh0U2VsZWN0aW9uQWNyb3NzQ2VsbHMoc2VsKSkge1xuICAgIG5vcm1hbGl6ZSA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgc2VsLiRmcm9tLnN0YXJ0KCksIHNlbC4kZnJvbS5lbmQoKSk7XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZSkgKHRyIHx8ICh0ciA9IHN0YXRlLnRyKSkuc2V0U2VsZWN0aW9uKG5vcm1hbGl6ZSk7XG4gIHJldHVybiB0cjtcbn1cblxuLy8gc3JjL2ZpeHRhYmxlcy50c1xuaW1wb3J0IHsgUGx1Z2luS2V5IGFzIFBsdWdpbktleTIgfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbnZhciBmaXhUYWJsZXNLZXkgPSBuZXcgUGx1Z2luS2V5MihcImZpeC10YWJsZXNcIik7XG5mdW5jdGlvbiBjaGFuZ2VkRGVzY2VuZGFudHMob2xkLCBjdXIsIG9mZnNldCwgZikge1xuICBjb25zdCBvbGRTaXplID0gb2xkLmNoaWxkQ291bnQsIGN1clNpemUgPSBjdXIuY2hpbGRDb3VudDtcbiAgb3V0ZXI6IGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGN1clNpemU7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY3VyLmNoaWxkKGkpO1xuICAgIGZvciAobGV0IHNjYW4gPSBqLCBlID0gTWF0aC5taW4ob2xkU2l6ZSwgaSArIDMpOyBzY2FuIDwgZTsgc2NhbisrKSB7XG4gICAgICBpZiAob2xkLmNoaWxkKHNjYW4pID09IGNoaWxkKSB7XG4gICAgICAgIGogPSBzY2FuICsgMTtcbiAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZihjaGlsZCwgb2Zmc2V0KTtcbiAgICBpZiAoaiA8IG9sZFNpemUgJiYgb2xkLmNoaWxkKGopLnNhbWVNYXJrdXAoY2hpbGQpKVxuICAgICAgY2hhbmdlZERlc2NlbmRhbnRzKG9sZC5jaGlsZChqKSwgY2hpbGQsIG9mZnNldCArIDEsIGYpO1xuICAgIGVsc2UgY2hpbGQubm9kZXNCZXR3ZWVuKDAsIGNoaWxkLmNvbnRlbnQuc2l6ZSwgZiwgb2Zmc2V0ICsgMSk7XG4gICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICB9XG59XG5mdW5jdGlvbiBmaXhUYWJsZXMoc3RhdGUsIG9sZFN0YXRlKSB7XG4gIGxldCB0cjtcbiAgY29uc3QgY2hlY2sgPSAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInRhYmxlXCIpXG4gICAgICB0ciA9IGZpeFRhYmxlKHN0YXRlLCBub2RlLCBwb3MsIHRyKTtcbiAgfTtcbiAgaWYgKCFvbGRTdGF0ZSkgc3RhdGUuZG9jLmRlc2NlbmRhbnRzKGNoZWNrKTtcbiAgZWxzZSBpZiAob2xkU3RhdGUuZG9jICE9IHN0YXRlLmRvYylcbiAgICBjaGFuZ2VkRGVzY2VuZGFudHMob2xkU3RhdGUuZG9jLCBzdGF0ZS5kb2MsIDAsIGNoZWNrKTtcbiAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gZml4VGFibGUoc3RhdGUsIHRhYmxlLCB0YWJsZVBvcywgdHIpIHtcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgaWYgKCFtYXAucHJvYmxlbXMpIHJldHVybiB0cjtcbiAgaWYgKCF0cikgdHIgPSBzdGF0ZS50cjtcbiAgY29uc3QgbXVzdEFkZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcC5oZWlnaHQ7IGkrKykgbXVzdEFkZC5wdXNoKDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcC5wcm9ibGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb2IgPSBtYXAucHJvYmxlbXNbaV07XG4gICAgaWYgKHByb2IudHlwZSA9PSBcImNvbGxpc2lvblwiKSB7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHByb2IucG9zKTtcbiAgICAgIGlmICghY2VsbCkgY29udGludWU7XG4gICAgICBjb25zdCBhdHRycyA9IGNlbGwuYXR0cnM7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHJzLnJvd3NwYW47IGorKykgbXVzdEFkZFtwcm9iLnJvdyArIGpdICs9IHByb2IubjtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgIHRyLm1hcHBpbmcubWFwKHRhYmxlUG9zICsgMSArIHByb2IucG9zKSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVtb3ZlQ29sU3BhbihhdHRycywgYXR0cnMuY29sc3BhbiAtIHByb2IubiwgcHJvYi5uKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHByb2IudHlwZSA9PSBcIm1pc3NpbmdcIikge1xuICAgICAgbXVzdEFkZFtwcm9iLnJvd10gKz0gcHJvYi5uO1xuICAgIH0gZWxzZSBpZiAocHJvYi50eXBlID09IFwib3Zlcmxvbmdfcm93c3BhblwiKSB7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHByb2IucG9zKTtcbiAgICAgIGlmICghY2VsbCkgY29udGludWU7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKHRhYmxlUG9zICsgMSArIHByb2IucG9zKSwgbnVsbCwge1xuICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICByb3dzcGFuOiBjZWxsLmF0dHJzLnJvd3NwYW4gLSBwcm9iLm5cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocHJvYi50eXBlID09IFwiY29sd2lkdGggbWlzbWF0Y2hcIikge1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwcm9iLnBvcyk7XG4gICAgICBpZiAoIWNlbGwpIGNvbnRpbnVlO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCh0YWJsZVBvcyArIDEgKyBwcm9iLnBvcyksIG51bGwsIHtcbiAgICAgICAgLi4uY2VsbC5hdHRycyxcbiAgICAgICAgY29sd2lkdGg6IHByb2IuY29sd2lkdGhcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocHJvYi50eXBlID09IFwiemVyb19zaXplZFwiKSB7XG4gICAgICBjb25zdCBwb3MgPSB0ci5tYXBwaW5nLm1hcCh0YWJsZVBvcyk7XG4gICAgICB0ci5kZWxldGUocG9zLCBwb3MgKyB0YWJsZS5ub2RlU2l6ZSk7XG4gICAgfVxuICB9XG4gIGxldCBmaXJzdCwgbGFzdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXN0QWRkLmxlbmd0aDsgaSsrKVxuICAgIGlmIChtdXN0QWRkW2ldKSB7XG4gICAgICBpZiAoZmlyc3QgPT0gbnVsbCkgZmlyc3QgPSBpO1xuICAgICAgbGFzdCA9IGk7XG4gICAgfVxuICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGFibGVQb3MgKyAxOyBpIDwgbWFwLmhlaWdodDsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gdGFibGUuY2hpbGQoaSk7XG4gICAgY29uc3QgZW5kID0gcG9zICsgcm93Lm5vZGVTaXplO1xuICAgIGNvbnN0IGFkZCA9IG11c3RBZGRbaV07XG4gICAgaWYgKGFkZCA+IDApIHtcbiAgICAgIGxldCByb2xlID0gXCJjZWxsXCI7XG4gICAgICBpZiAocm93LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcm9sZSA9IHJvdy5maXJzdENoaWxkLnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhZGQ7IGorKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKVtyb2xlXS5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgIGlmIChub2RlKSBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lkZSA9IChpID09IDAgfHwgZmlyc3QgPT0gaSAtIDEpICYmIGxhc3QgPT0gaSA/IHBvcyArIDEgOiBlbmQgLSAxO1xuICAgICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKHNpZGUpLCBub2Rlcyk7XG4gICAgfVxuICAgIHBvcyA9IGVuZDtcbiAgfVxuICByZXR1cm4gdHIuc2V0TWV0YShmaXhUYWJsZXNLZXksIHsgZml4VGFibGVzOiB0cnVlIH0pO1xufVxuXG4vLyBzcmMvaW5wdXQudHNcbmltcG9ydCB7IGtleWRvd25IYW5kbGVyIH0gZnJvbSBcInByb3NlbWlycm9yLWtleW1hcFwiO1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQ0IH0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQge1xuICBTZWxlY3Rpb24gYXMgU2VsZWN0aW9uMixcbiAgVGV4dFNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uM1xufSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcblxuLy8gc3JjL2NvbW1hbmRzLnRzXG5pbXBvcnQge1xuICBGcmFnbWVudCBhcyBGcmFnbWVudDIsXG4gIFNsaWNlIGFzIFNsaWNlMlxufSBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbmltcG9ydCB7XG4gIFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjJcbn0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5cbi8vIHNyYy91dGlscy9jb252ZXJ0LnRzXG5mdW5jdGlvbiBjb252ZXJ0VGFibGVOb2RlVG9BcnJheU9mUm93cyh0YWJsZU5vZGUpIHtcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlTm9kZSk7XG4gIGNvbnN0IHJvd3MgPSBbXTtcbiAgY29uc3Qgcm93Q291bnQgPSBtYXAuaGVpZ2h0O1xuICBjb25zdCBjb2xDb3VudDIgPSBtYXAud2lkdGg7XG4gIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCByb3dDb3VudDsgcm93SW5kZXgrKykge1xuICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgIGZvciAobGV0IGNvbEluZGV4ID0gMDsgY29sSW5kZXggPCBjb2xDb3VudDI7IGNvbEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGNlbGxJbmRleCA9IHJvd0luZGV4ICogY29sQ291bnQyICsgY29sSW5kZXg7XG4gICAgICBjb25zdCBjZWxsUG9zID0gbWFwLm1hcFtjZWxsSW5kZXhdO1xuICAgICAgaWYgKHJvd0luZGV4ID4gMCkge1xuICAgICAgICBjb25zdCB0b3BDZWxsSW5kZXggPSBjZWxsSW5kZXggLSBjb2xDb3VudDI7XG4gICAgICAgIGNvbnN0IHRvcENlbGxQb3MgPSBtYXAubWFwW3RvcENlbGxJbmRleF07XG4gICAgICAgIGlmIChjZWxsUG9zID09PSB0b3BDZWxsUG9zKSB7XG4gICAgICAgICAgcm93LnB1c2gobnVsbCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb2xJbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgbGVmdENlbGxJbmRleCA9IGNlbGxJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGxlZnRDZWxsUG9zID0gbWFwLm1hcFtsZWZ0Q2VsbEluZGV4XTtcbiAgICAgICAgaWYgKGNlbGxQb3MgPT09IGxlZnRDZWxsUG9zKSB7XG4gICAgICAgICAgcm93LnB1c2gobnVsbCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJvdy5wdXNoKHRhYmxlTm9kZS5ub2RlQXQoY2VsbFBvcykpO1xuICAgIH1cbiAgICByb3dzLnB1c2gocm93KTtcbiAgfVxuICByZXR1cm4gcm93cztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRBcnJheU9mUm93c1RvVGFibGVOb2RlKHRhYmxlTm9kZSwgYXJyYXlPZk5vZGVzKSB7XG4gIGNvbnN0IG5ld1Jvd3MgPSBbXTtcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlTm9kZSk7XG4gIGNvbnN0IHJvd0NvdW50ID0gbWFwLmhlaWdodDtcbiAgY29uc3QgY29sQ291bnQyID0gbWFwLndpZHRoO1xuICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93Q291bnQ7IHJvd0luZGV4KyspIHtcbiAgICBjb25zdCBvbGRSb3cgPSB0YWJsZU5vZGUuY2hpbGQocm93SW5kZXgpO1xuICAgIGNvbnN0IG5ld0NlbGxzID0gW107XG4gICAgZm9yIChsZXQgY29sSW5kZXggPSAwOyBjb2xJbmRleCA8IGNvbENvdW50MjsgY29sSW5kZXgrKykge1xuICAgICAgY29uc3QgY2VsbCA9IGFycmF5T2ZOb2Rlc1tyb3dJbmRleF1bY29sSW5kZXhdO1xuICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2VsbFBvcyA9IG1hcC5tYXBbcm93SW5kZXggKiBtYXAud2lkdGggKyBjb2xJbmRleF07XG4gICAgICBjb25zdCBvbGRDZWxsID0gdGFibGVOb2RlLm5vZGVBdChjZWxsUG9zKTtcbiAgICAgIGlmICghb2xkQ2VsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NlbGwgPSBvbGRDZWxsLnR5cGUuY3JlYXRlQ2hlY2tlZChcbiAgICAgICAgY2VsbC5hdHRycyxcbiAgICAgICAgY2VsbC5jb250ZW50LFxuICAgICAgICBjZWxsLm1hcmtzXG4gICAgICApO1xuICAgICAgbmV3Q2VsbHMucHVzaChuZXdDZWxsKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Um93ID0gb2xkUm93LnR5cGUuY3JlYXRlQ2hlY2tlZChcbiAgICAgIG9sZFJvdy5hdHRycyxcbiAgICAgIG5ld0NlbGxzLFxuICAgICAgb2xkUm93Lm1hcmtzXG4gICAgKTtcbiAgICBuZXdSb3dzLnB1c2gobmV3Um93KTtcbiAgfVxuICBjb25zdCBuZXdUYWJsZSA9IHRhYmxlTm9kZS50eXBlLmNyZWF0ZUNoZWNrZWQoXG4gICAgdGFibGVOb2RlLmF0dHJzLFxuICAgIG5ld1Jvd3MsXG4gICAgdGFibGVOb2RlLm1hcmtzXG4gICk7XG4gIHJldHVybiBuZXdUYWJsZTtcbn1cblxuLy8gc3JjL3V0aWxzL3F1ZXJ5LnRzXG5mdW5jdGlvbiBpc0NlbGxTZWxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGZpbmRUYWJsZSgkcG9zKSB7XG4gIHJldHVybiBmaW5kUGFyZW50Tm9kZSgobm9kZSkgPT4gbm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcInRhYmxlXCIsICRwb3MpO1xufVxuZnVuY3Rpb24gZmluZENlbGxSYW5nZShzZWxlY3Rpb24sIGFuY2hvckhpdCwgaGVhZEhpdCkge1xuICB2YXIgX2EsIF9iO1xuICBpZiAoYW5jaG9ySGl0ID09IG51bGwgJiYgaGVhZEhpdCA9PSBudWxsICYmIGlzQ2VsbFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIFtzZWxlY3Rpb24uJGFuY2hvckNlbGwsIHNlbGVjdGlvbi4kaGVhZENlbGxdO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IChfYSA9IGFuY2hvckhpdCAhPSBudWxsID8gYW5jaG9ySGl0IDogaGVhZEhpdCkgIT0gbnVsbCA/IF9hIDogc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgaGVhZCA9IChfYiA9IGhlYWRIaXQgIT0gbnVsbCA/IGhlYWRIaXQgOiBhbmNob3JIaXQpICE9IG51bGwgPyBfYiA6IHNlbGVjdGlvbi5oZWFkO1xuICBjb25zdCBkb2MgPSBzZWxlY3Rpb24uJGhlYWQuZG9jO1xuICBjb25zdCAkYW5jaG9yQ2VsbCA9IGZpbmRDZWxsUG9zKGRvYywgYW5jaG9yKTtcbiAgY29uc3QgJGhlYWRDZWxsID0gZmluZENlbGxQb3MoZG9jLCBoZWFkKTtcbiAgaWYgKCRhbmNob3JDZWxsICYmICRoZWFkQ2VsbCAmJiBpblNhbWVUYWJsZSgkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKSkge1xuICAgIHJldHVybiBbJGFuY2hvckNlbGwsICRoZWFkQ2VsbF07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ2VsbFBvcyhkb2MsIHBvcykge1xuICBjb25zdCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgcmV0dXJuIGNlbGxBcm91bmQoJHBvcykgfHwgY2VsbE5lYXIoJHBvcyk7XG59XG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGUsICRwb3MpIHtcbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+PSAwOyBkZXB0aCAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aCk7XG4gICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgY29uc3QgcG9zID0gZGVwdGggPT09IDAgPyAwIDogJHBvcy5iZWZvcmUoZGVwdGgpO1xuICAgICAgY29uc3Qgc3RhcnQgPSAkcG9zLnN0YXJ0KGRlcHRoKTtcbiAgICAgIHJldHVybiB7IG5vZGUsIHBvcywgc3RhcnQsIGRlcHRoIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvdXRpbHMvZ2V0LWNlbGxzLnRzXG5mdW5jdGlvbiBnZXRDZWxsc0luQ29sdW1uKGNvbHVtbkluZGV4LCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgdGFibGUgPSBmaW5kVGFibGUoc2VsZWN0aW9uLiRmcm9tKTtcbiAgaWYgKCF0YWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUubm9kZSk7XG4gIGlmIChjb2x1bW5JbmRleCA8IDAgfHwgY29sdW1uSW5kZXggPiBtYXAud2lkdGggLSAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNlbGxzID0gbWFwLmNlbGxzSW5SZWN0KHtcbiAgICBsZWZ0OiBjb2x1bW5JbmRleCxcbiAgICByaWdodDogY29sdW1uSW5kZXggKyAxLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IG1hcC5oZWlnaHRcbiAgfSk7XG4gIHJldHVybiBjZWxscy5tYXAoKG5vZGVQb3MpID0+IHtcbiAgICBjb25zdCBub2RlID0gdGFibGUubm9kZS5ub2RlQXQobm9kZVBvcyk7XG4gICAgY29uc3QgcG9zID0gbm9kZVBvcyArIHRhYmxlLnN0YXJ0O1xuICAgIHJldHVybiB7IHBvcywgc3RhcnQ6IHBvcyArIDEsIG5vZGUsIGRlcHRoOiB0YWJsZS5kZXB0aCArIDIgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDZWxsc0luUm93KHJvd0luZGV4LCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgdGFibGUgPSBmaW5kVGFibGUoc2VsZWN0aW9uLiRmcm9tKTtcbiAgaWYgKCF0YWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUubm9kZSk7XG4gIGlmIChyb3dJbmRleCA8IDAgfHwgcm93SW5kZXggPiBtYXAuaGVpZ2h0IC0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjZWxscyA9IG1hcC5jZWxsc0luUmVjdCh7XG4gICAgbGVmdDogMCxcbiAgICByaWdodDogbWFwLndpZHRoLFxuICAgIHRvcDogcm93SW5kZXgsXG4gICAgYm90dG9tOiByb3dJbmRleCArIDFcbiAgfSk7XG4gIHJldHVybiBjZWxscy5tYXAoKG5vZGVQb3MpID0+IHtcbiAgICBjb25zdCBub2RlID0gdGFibGUubm9kZS5ub2RlQXQobm9kZVBvcyk7XG4gICAgY29uc3QgcG9zID0gbm9kZVBvcyArIHRhYmxlLnN0YXJ0O1xuICAgIHJldHVybiB7IHBvcywgc3RhcnQ6IHBvcyArIDEsIG5vZGUsIGRlcHRoOiB0YWJsZS5kZXB0aCArIDIgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlscy9zZWxlY3Rpb24tcmFuZ2UudHNcbmZ1bmN0aW9uIGdldFNlbGVjdGlvblJhbmdlSW5Db2x1bW4odHIsIHN0YXJ0Q29sSW5kZXgsIGVuZENvbEluZGV4ID0gc3RhcnRDb2xJbmRleCkge1xuICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0Q29sSW5kZXg7XG4gIGxldCBlbmRJbmRleCA9IGVuZENvbEluZGV4O1xuICBmb3IgKGxldCBpID0gc3RhcnRDb2xJbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBjZWxscyA9IGdldENlbGxzSW5Db2x1bW4oaSwgdHIuc2VsZWN0aW9uKTtcbiAgICBpZiAoY2VsbHMpIHtcbiAgICAgIGNlbGxzLmZvckVhY2goKGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgbWF5YmVFbmRJbmRleCA9IGNlbGwubm9kZS5hdHRycy5jb2xzcGFuICsgaSAtIDE7XG4gICAgICAgIGlmIChtYXliZUVuZEluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmVFbmRJbmRleCA+IGVuZEluZGV4KSB7XG4gICAgICAgICAgZW5kSW5kZXggPSBtYXliZUVuZEluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IHN0YXJ0Q29sSW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkrKykge1xuICAgIGNvbnN0IGNlbGxzID0gZ2V0Q2VsbHNJbkNvbHVtbihpLCB0ci5zZWxlY3Rpb24pO1xuICAgIGlmIChjZWxscykge1xuICAgICAgY2VsbHMuZm9yRWFjaCgoY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCBtYXliZUVuZEluZGV4ID0gY2VsbC5ub2RlLmF0dHJzLmNvbHNwYW4gKyBpIC0gMTtcbiAgICAgICAgaWYgKGNlbGwubm9kZS5hdHRycy5jb2xzcGFuID4gMSAmJiBtYXliZUVuZEluZGV4ID4gZW5kSW5kZXgpIHtcbiAgICAgICAgICBlbmRJbmRleCA9IG1heWJlRW5kSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBpbmRleGVzID0gW107XG4gIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcbiAgICBjb25zdCBtYXliZUNlbGxzID0gZ2V0Q2VsbHNJbkNvbHVtbihpLCB0ci5zZWxlY3Rpb24pO1xuICAgIGlmIChtYXliZUNlbGxzICYmIG1heWJlQ2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICBzdGFydEluZGV4ID0gaW5kZXhlc1swXTtcbiAgZW5kSW5kZXggPSBpbmRleGVzW2luZGV4ZXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGZpcnN0U2VsZWN0ZWRDb2x1bW5DZWxscyA9IGdldENlbGxzSW5Db2x1bW4oc3RhcnRJbmRleCwgdHIuc2VsZWN0aW9uKTtcbiAgY29uc3QgZmlyc3RSb3dDZWxscyA9IGdldENlbGxzSW5Sb3coMCwgdHIuc2VsZWN0aW9uKTtcbiAgaWYgKCFmaXJzdFNlbGVjdGVkQ29sdW1uQ2VsbHMgfHwgIWZpcnN0Um93Q2VsbHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgJGFuY2hvciA9IHRyLmRvYy5yZXNvbHZlKFxuICAgIGZpcnN0U2VsZWN0ZWRDb2x1bW5DZWxsc1tmaXJzdFNlbGVjdGVkQ29sdW1uQ2VsbHMubGVuZ3RoIC0gMV0ucG9zXG4gICk7XG4gIGxldCBoZWFkQ2VsbDtcbiAgZm9yIChsZXQgaSA9IGVuZEluZGV4OyBpID49IHN0YXJ0SW5kZXg7IGktLSkge1xuICAgIGNvbnN0IGNvbHVtbkNlbGxzID0gZ2V0Q2VsbHNJbkNvbHVtbihpLCB0ci5zZWxlY3Rpb24pO1xuICAgIGlmIChjb2x1bW5DZWxscyAmJiBjb2x1bW5DZWxscy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBqID0gZmlyc3RSb3dDZWxscy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBpZiAoZmlyc3RSb3dDZWxsc1tqXS5wb3MgPT09IGNvbHVtbkNlbGxzWzBdLnBvcykge1xuICAgICAgICAgIGhlYWRDZWxsID0gY29sdW1uQ2VsbHNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoZWFkQ2VsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFoZWFkQ2VsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCAkaGVhZCA9IHRyLmRvYy5yZXNvbHZlKGhlYWRDZWxsLnBvcyk7XG4gIHJldHVybiB7ICRhbmNob3IsICRoZWFkLCBpbmRleGVzIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZUluUm93KHRyLCBzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCA9IHN0YXJ0Um93SW5kZXgpIHtcbiAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydFJvd0luZGV4O1xuICBsZXQgZW5kSW5kZXggPSBlbmRSb3dJbmRleDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0Um93SW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgY2VsbHMgPSBnZXRDZWxsc0luUm93KGksIHRyLnNlbGVjdGlvbik7XG4gICAgaWYgKGNlbGxzKSB7XG4gICAgICBjZWxscy5mb3JFYWNoKChjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IG1heWJlRW5kSW5kZXggPSBjZWxsLm5vZGUuYXR0cnMucm93c3BhbiArIGkgLSAxO1xuICAgICAgICBpZiAobWF5YmVFbmRJbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlRW5kSW5kZXggPiBlbmRJbmRleCkge1xuICAgICAgICAgIGVuZEluZGV4ID0gbWF5YmVFbmRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSBzdGFydFJvd0luZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcbiAgICBjb25zdCBjZWxscyA9IGdldENlbGxzSW5Sb3coaSwgdHIuc2VsZWN0aW9uKTtcbiAgICBpZiAoY2VsbHMpIHtcbiAgICAgIGNlbGxzLmZvckVhY2goKGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgbWF5YmVFbmRJbmRleCA9IGNlbGwubm9kZS5hdHRycy5yb3dzcGFuICsgaSAtIDE7XG4gICAgICAgIGlmIChjZWxsLm5vZGUuYXR0cnMucm93c3BhbiA+IDEgJiYgbWF5YmVFbmRJbmRleCA+IGVuZEluZGV4KSB7XG4gICAgICAgICAgZW5kSW5kZXggPSBtYXliZUVuZEluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgbWF5YmVDZWxscyA9IGdldENlbGxzSW5Sb3coaSwgdHIuc2VsZWN0aW9uKTtcbiAgICBpZiAobWF5YmVDZWxscyAmJiBtYXliZUNlbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRJbmRleCA9IGluZGV4ZXNbMF07XG4gIGVuZEluZGV4ID0gaW5kZXhlc1tpbmRleGVzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBmaXJzdFNlbGVjdGVkUm93Q2VsbHMgPSBnZXRDZWxsc0luUm93KHN0YXJ0SW5kZXgsIHRyLnNlbGVjdGlvbik7XG4gIGNvbnN0IGZpcnN0Q29sdW1uQ2VsbHMgPSBnZXRDZWxsc0luQ29sdW1uKDAsIHRyLnNlbGVjdGlvbik7XG4gIGlmICghZmlyc3RTZWxlY3RlZFJvd0NlbGxzIHx8ICFmaXJzdENvbHVtbkNlbGxzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0ICRhbmNob3IgPSB0ci5kb2MucmVzb2x2ZShcbiAgICBmaXJzdFNlbGVjdGVkUm93Q2VsbHNbZmlyc3RTZWxlY3RlZFJvd0NlbGxzLmxlbmd0aCAtIDFdLnBvc1xuICApO1xuICBsZXQgaGVhZENlbGw7XG4gIGZvciAobGV0IGkgPSBlbmRJbmRleDsgaSA+PSBzdGFydEluZGV4OyBpLS0pIHtcbiAgICBjb25zdCByb3dDZWxscyA9IGdldENlbGxzSW5Sb3coaSwgdHIuc2VsZWN0aW9uKTtcbiAgICBpZiAocm93Q2VsbHMgJiYgcm93Q2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaiA9IGZpcnN0Q29sdW1uQ2VsbHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgaWYgKGZpcnN0Q29sdW1uQ2VsbHNbal0ucG9zID09PSByb3dDZWxsc1swXS5wb3MpIHtcbiAgICAgICAgICBoZWFkQ2VsbCA9IHJvd0NlbGxzWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGVhZENlbGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaGVhZENlbGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgJGhlYWQgPSB0ci5kb2MucmVzb2x2ZShoZWFkQ2VsbC5wb3MpO1xuICByZXR1cm4geyAkYW5jaG9yLCAkaGVhZCwgaW5kZXhlcyB9O1xufVxuXG4vLyBzcmMvdXRpbHMvbW92ZS1yb3ctaW4tYXJyYXktb2Ytcm93cy50c1xuZnVuY3Rpb24gbW92ZVJvd0luQXJyYXlPZlJvd3Mocm93cywgaW5kZXhlc09yaWdpbiwgaW5kZXhlc1RhcmdldCwgZGlyZWN0aW9uT3ZlcnJpZGUpIHtcbiAgY29uc3QgZGlyZWN0aW9uID0gaW5kZXhlc09yaWdpblswXSA+IGluZGV4ZXNUYXJnZXRbMF0gPyAtMSA6IDE7XG4gIGNvbnN0IHJvd3NFeHRyYWN0ZWQgPSByb3dzLnNwbGljZShpbmRleGVzT3JpZ2luWzBdLCBpbmRleGVzT3JpZ2luLmxlbmd0aCk7XG4gIGNvbnN0IHBvc2l0aW9uT2Zmc2V0ID0gcm93c0V4dHJhY3RlZC5sZW5ndGggJSAyID09PSAwID8gMSA6IDA7XG4gIGxldCB0YXJnZXQ7XG4gIGlmIChkaXJlY3Rpb25PdmVycmlkZSA9PT0gLTEgJiYgZGlyZWN0aW9uID09PSAxKSB7XG4gICAgdGFyZ2V0ID0gaW5kZXhlc1RhcmdldFswXSAtIDE7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uT3ZlcnJpZGUgPT09IDEgJiYgZGlyZWN0aW9uID09PSAtMSkge1xuICAgIHRhcmdldCA9IGluZGV4ZXNUYXJnZXRbaW5kZXhlc1RhcmdldC5sZW5ndGggLSAxXSAtIHBvc2l0aW9uT2Zmc2V0ICsgMTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSBkaXJlY3Rpb24gPT09IC0xID8gaW5kZXhlc1RhcmdldFswXSA6IGluZGV4ZXNUYXJnZXRbaW5kZXhlc1RhcmdldC5sZW5ndGggLSAxXSAtIHBvc2l0aW9uT2Zmc2V0O1xuICB9XG4gIHJvd3Muc3BsaWNlKHRhcmdldCwgMCwgLi4ucm93c0V4dHJhY3RlZCk7XG4gIHJldHVybiByb3dzO1xufVxuXG4vLyBzcmMvdXRpbHMvdHJhbnNwb3NlLnRzXG5mdW5jdGlvbiB0cmFuc3Bvc2UoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5WzBdLm1hcCgoXywgaSkgPT4ge1xuICAgIHJldHVybiBhcnJheS5tYXAoKGNvbHVtbikgPT4gY29sdW1uW2ldKTtcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlscy9tb3ZlLWNvbHVtbi50c1xuZnVuY3Rpb24gbW92ZUNvbHVtbihtb3ZlQ29sUGFyYW1zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHsgdHIsIG9yaWdpbkluZGV4LCB0YXJnZXRJbmRleCwgc2VsZWN0LCBwb3MgfSA9IG1vdmVDb2xQYXJhbXM7XG4gIGNvbnN0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpO1xuICBjb25zdCB0YWJsZSA9IGZpbmRUYWJsZSgkcG9zKTtcbiAgaWYgKCF0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBpbmRleGVzT3JpZ2luQ29sdW1uID0gKF9hID0gZ2V0U2VsZWN0aW9uUmFuZ2VJbkNvbHVtbihcbiAgICB0cixcbiAgICBvcmlnaW5JbmRleFxuICApKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5kZXhlcztcbiAgY29uc3QgaW5kZXhlc1RhcmdldENvbHVtbiA9IChfYiA9IGdldFNlbGVjdGlvblJhbmdlSW5Db2x1bW4oXG4gICAgdHIsXG4gICAgdGFyZ2V0SW5kZXhcbiAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmluZGV4ZXM7XG4gIGlmICghaW5kZXhlc09yaWdpbkNvbHVtbiB8fCAhaW5kZXhlc1RhcmdldENvbHVtbikgcmV0dXJuIGZhbHNlO1xuICBpZiAoaW5kZXhlc09yaWdpbkNvbHVtbi5pbmNsdWRlcyh0YXJnZXRJbmRleCkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbmV3VGFibGUgPSBtb3ZlVGFibGVDb2x1bW4oXG4gICAgdGFibGUubm9kZSxcbiAgICBpbmRleGVzT3JpZ2luQ29sdW1uLFxuICAgIGluZGV4ZXNUYXJnZXRDb2x1bW4sXG4gICAgMFxuICApO1xuICB0ci5yZXBsYWNlV2l0aCh0YWJsZS5wb3MsIHRhYmxlLnBvcyArIHRhYmxlLm5vZGUubm9kZVNpemUsIG5ld1RhYmxlKTtcbiAgaWYgKCFzZWxlY3QpIHJldHVybiB0cnVlO1xuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQobmV3VGFibGUpO1xuICBjb25zdCBzdGFydCA9IHRhYmxlLnN0YXJ0O1xuICBjb25zdCBpbmRleCA9IHRhcmdldEluZGV4O1xuICBjb25zdCBsYXN0Q2VsbCA9IG1hcC5wb3NpdGlvbkF0KG1hcC5oZWlnaHQgLSAxLCBpbmRleCwgbmV3VGFibGUpO1xuICBjb25zdCAkbGFzdENlbGwgPSB0ci5kb2MucmVzb2x2ZShzdGFydCArIGxhc3RDZWxsKTtcbiAgY29uc3QgZmlyc3RDZWxsID0gbWFwLnBvc2l0aW9uQXQoMCwgaW5kZXgsIG5ld1RhYmxlKTtcbiAgY29uc3QgJGZpcnN0Q2VsbCA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0ICsgZmlyc3RDZWxsKTtcbiAgdHIuc2V0U2VsZWN0aW9uKENlbGxTZWxlY3Rpb24uY29sU2VsZWN0aW9uKCRsYXN0Q2VsbCwgJGZpcnN0Q2VsbCkpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1vdmVUYWJsZUNvbHVtbih0YWJsZSwgaW5kZXhlc09yaWdpbiwgaW5kZXhlc1RhcmdldCwgZGlyZWN0aW9uKSB7XG4gIGxldCByb3dzID0gdHJhbnNwb3NlKGNvbnZlcnRUYWJsZU5vZGVUb0FycmF5T2ZSb3dzKHRhYmxlKSk7XG4gIHJvd3MgPSBtb3ZlUm93SW5BcnJheU9mUm93cyhyb3dzLCBpbmRleGVzT3JpZ2luLCBpbmRleGVzVGFyZ2V0LCBkaXJlY3Rpb24pO1xuICByb3dzID0gdHJhbnNwb3NlKHJvd3MpO1xuICByZXR1cm4gY29udmVydEFycmF5T2ZSb3dzVG9UYWJsZU5vZGUodGFibGUsIHJvd3MpO1xufVxuXG4vLyBzcmMvdXRpbHMvbW92ZS1yb3cudHNcbmZ1bmN0aW9uIG1vdmVSb3cobW92ZVJvd1BhcmFtcykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB7IHRyLCBvcmlnaW5JbmRleCwgdGFyZ2V0SW5kZXgsIHNlbGVjdCwgcG9zIH0gPSBtb3ZlUm93UGFyYW1zO1xuICBjb25zdCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKTtcbiAgY29uc3QgdGFibGUgPSBmaW5kVGFibGUoJHBvcyk7XG4gIGlmICghdGFibGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgaW5kZXhlc09yaWdpblJvdyA9IChfYSA9IGdldFNlbGVjdGlvblJhbmdlSW5Sb3codHIsIG9yaWdpbkluZGV4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluZGV4ZXM7XG4gIGNvbnN0IGluZGV4ZXNUYXJnZXRSb3cgPSAoX2IgPSBnZXRTZWxlY3Rpb25SYW5nZUluUm93KHRyLCB0YXJnZXRJbmRleCkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmRleGVzO1xuICBpZiAoIWluZGV4ZXNPcmlnaW5Sb3cgfHwgIWluZGV4ZXNUYXJnZXRSb3cpIHJldHVybiBmYWxzZTtcbiAgaWYgKGluZGV4ZXNPcmlnaW5Sb3cuaW5jbHVkZXModGFyZ2V0SW5kZXgpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5ld1RhYmxlID0gbW92ZVRhYmxlUm93KFxuICAgIHRhYmxlLm5vZGUsXG4gICAgaW5kZXhlc09yaWdpblJvdyxcbiAgICBpbmRleGVzVGFyZ2V0Um93LFxuICAgIDBcbiAgKTtcbiAgdHIucmVwbGFjZVdpdGgodGFibGUucG9zLCB0YWJsZS5wb3MgKyB0YWJsZS5ub2RlLm5vZGVTaXplLCBuZXdUYWJsZSk7XG4gIGlmICghc2VsZWN0KSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KG5ld1RhYmxlKTtcbiAgY29uc3Qgc3RhcnQgPSB0YWJsZS5zdGFydDtcbiAgY29uc3QgaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgY29uc3QgbGFzdENlbGwgPSBtYXAucG9zaXRpb25BdChpbmRleCwgbWFwLndpZHRoIC0gMSwgbmV3VGFibGUpO1xuICBjb25zdCAkbGFzdENlbGwgPSB0ci5kb2MucmVzb2x2ZShzdGFydCArIGxhc3RDZWxsKTtcbiAgY29uc3QgZmlyc3RDZWxsID0gbWFwLnBvc2l0aW9uQXQoaW5kZXgsIDAsIG5ld1RhYmxlKTtcbiAgY29uc3QgJGZpcnN0Q2VsbCA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0ICsgZmlyc3RDZWxsKTtcbiAgdHIuc2V0U2VsZWN0aW9uKENlbGxTZWxlY3Rpb24ucm93U2VsZWN0aW9uKCRsYXN0Q2VsbCwgJGZpcnN0Q2VsbCkpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1vdmVUYWJsZVJvdyh0YWJsZSwgaW5kZXhlc09yaWdpbiwgaW5kZXhlc1RhcmdldCwgZGlyZWN0aW9uKSB7XG4gIGxldCByb3dzID0gY29udmVydFRhYmxlTm9kZVRvQXJyYXlPZlJvd3ModGFibGUpO1xuICByb3dzID0gbW92ZVJvd0luQXJyYXlPZlJvd3Mocm93cywgaW5kZXhlc09yaWdpbiwgaW5kZXhlc1RhcmdldCwgZGlyZWN0aW9uKTtcbiAgcmV0dXJuIGNvbnZlcnRBcnJheU9mUm93c1RvVGFibGVOb2RlKHRhYmxlLCByb3dzKTtcbn1cblxuLy8gc3JjL2NvbW1hbmRzLnRzXG5mdW5jdGlvbiBzZWxlY3RlZFJlY3Qoc3RhdGUpIHtcbiAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICBjb25zdCAkcG9zID0gc2VsZWN0aW9uQ2VsbChzdGF0ZSk7XG4gIGNvbnN0IHRhYmxlID0gJHBvcy5ub2RlKC0xKTtcbiAgY29uc3QgdGFibGVTdGFydCA9ICRwb3Muc3RhcnQoLTEpO1xuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICBjb25zdCByZWN0ID0gc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbiA/IG1hcC5yZWN0QmV0d2VlbihcbiAgICBzZWwuJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCxcbiAgICBzZWwuJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnRcbiAgKSA6IG1hcC5maW5kQ2VsbCgkcG9zLnBvcyAtIHRhYmxlU3RhcnQpO1xuICByZXR1cm4geyAuLi5yZWN0LCB0YWJsZVN0YXJ0LCBtYXAsIHRhYmxlIH07XG59XG5mdW5jdGlvbiBhZGRDb2x1bW4odHIsIHsgbWFwLCB0YWJsZVN0YXJ0LCB0YWJsZSB9LCBjb2wpIHtcbiAgbGV0IHJlZkNvbHVtbiA9IGNvbCA+IDAgPyAtMSA6IDA7XG4gIGlmIChjb2x1bW5Jc0hlYWRlcihtYXAsIHRhYmxlLCBjb2wgKyByZWZDb2x1bW4pKSB7XG4gICAgcmVmQ29sdW1uID0gY29sID09IDAgfHwgY29sID09IG1hcC53aWR0aCA/IG51bGwgOiAwO1xuICB9XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7IHJvdysrKSB7XG4gICAgY29uc3QgaW5kZXggPSByb3cgKiBtYXAud2lkdGggKyBjb2w7XG4gICAgaWYgKGNvbCA+IDAgJiYgY29sIDwgbWFwLndpZHRoICYmIG1hcC5tYXBbaW5kZXggLSAxXSA9PSBtYXAubWFwW2luZGV4XSkge1xuICAgICAgY29uc3QgcG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICB0ci5tYXBwaW5nLm1hcCh0YWJsZVN0YXJ0ICsgcG9zKSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYWRkQ29sU3BhbihjZWxsLmF0dHJzLCBjb2wgLSBtYXAuY29sQ291bnQocG9zKSlcbiAgICAgICk7XG4gICAgICByb3cgKz0gY2VsbC5hdHRycy5yb3dzcGFuIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IHJlZkNvbHVtbiA9PSBudWxsID8gdGFibGVOb2RlVHlwZXModGFibGUudHlwZS5zY2hlbWEpLmNlbGwgOiB0YWJsZS5ub2RlQXQobWFwLm1hcFtpbmRleCArIHJlZkNvbHVtbl0pLnR5cGU7XG4gICAgICBjb25zdCBwb3MgPSBtYXAucG9zaXRpb25BdChyb3csIGNvbCwgdGFibGUpO1xuICAgICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKHRhYmxlU3RhcnQgKyBwb3MpLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGFkZENvbHVtbkJlZm9yZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpO1xuICAgIGRpc3BhdGNoKGFkZENvbHVtbihzdGF0ZS50ciwgcmVjdCwgcmVjdC5sZWZ0KSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhZGRDb2x1bW5BZnRlcihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpO1xuICAgIGRpc3BhdGNoKGFkZENvbHVtbihzdGF0ZS50ciwgcmVjdCwgcmVjdC5yaWdodCkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ29sdW1uKHRyLCB7IG1hcCwgdGFibGUsIHRhYmxlU3RhcnQgfSwgY29sKSB7XG4gIGNvbnN0IG1hcFN0YXJ0ID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWFwLmhlaWdodDsgKSB7XG4gICAgY29uc3QgaW5kZXggPSByb3cgKiBtYXAud2lkdGggKyBjb2w7XG4gICAgY29uc3QgcG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuICAgIGNvbnN0IGF0dHJzID0gY2VsbC5hdHRycztcbiAgICBpZiAoY29sID4gMCAmJiBtYXAubWFwW2luZGV4IC0gMV0gPT0gcG9zIHx8IGNvbCA8IG1hcC53aWR0aCAtIDEgJiYgbWFwLm1hcFtpbmRleCArIDFdID09IHBvcykge1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgdHIubWFwcGluZy5zbGljZShtYXBTdGFydCkubWFwKHRhYmxlU3RhcnQgKyBwb3MpLFxuICAgICAgICBudWxsLFxuICAgICAgICByZW1vdmVDb2xTcGFuKGF0dHJzLCBjb2wgLSBtYXAuY29sQ291bnQocG9zKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdHIubWFwcGluZy5zbGljZShtYXBTdGFydCkubWFwKHRhYmxlU3RhcnQgKyBwb3MpO1xuICAgICAgdHIuZGVsZXRlKHN0YXJ0LCBzdGFydCArIGNlbGwubm9kZVNpemUpO1xuICAgIH1cbiAgICByb3cgKz0gYXR0cnMucm93c3BhbjtcbiAgfVxufVxuZnVuY3Rpb24gZGVsZXRlQ29sdW1uKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG4gICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICBpZiAocmVjdC5sZWZ0ID09IDAgJiYgcmVjdC5yaWdodCA9PSByZWN0Lm1hcC53aWR0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSByZWN0LnJpZ2h0IC0gMTsgOyBpLS0pIHtcbiAgICAgIHJlbW92ZUNvbHVtbih0ciwgcmVjdCwgaSk7XG4gICAgICBpZiAoaSA9PSByZWN0LmxlZnQpIGJyZWFrO1xuICAgICAgY29uc3QgdGFibGUgPSByZWN0LnRhYmxlU3RhcnQgPyB0ci5kb2Mubm9kZUF0KHJlY3QudGFibGVTdGFydCAtIDEpIDogdHIuZG9jO1xuICAgICAgaWYgKCF0YWJsZSkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiTm8gdGFibGUgZm91bmRcIik7XG4gICAgICB9XG4gICAgICByZWN0LnRhYmxlID0gdGFibGU7XG4gICAgICByZWN0Lm1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHRyKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJvd0lzSGVhZGVyKG1hcCwgdGFibGUsIHJvdykge1xuICB2YXIgX2E7XG4gIGNvbnN0IGhlYWRlckNlbGwgPSB0YWJsZU5vZGVUeXBlcyh0YWJsZS50eXBlLnNjaGVtYSkuaGVhZGVyX2NlbGw7XG4gIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IG1hcC53aWR0aDsgY29sKyspXG4gICAgaWYgKCgoX2EgPSB0YWJsZS5ub2RlQXQobWFwLm1hcFtjb2wgKyByb3cgKiBtYXAud2lkdGhdKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGUpICE9IGhlYWRlckNlbGwpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYWRkUm93KHRyLCB7IG1hcCwgdGFibGVTdGFydCwgdGFibGUgfSwgcm93KSB7XG4gIHZhciBfYTtcbiAgbGV0IHJvd1BvcyA9IHRhYmxlU3RhcnQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93OyBpKyspIHJvd1BvcyArPSB0YWJsZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgY29uc3QgY2VsbHMgPSBbXTtcbiAgbGV0IHJlZlJvdyA9IHJvdyA+IDAgPyAtMSA6IDA7XG4gIGlmIChyb3dJc0hlYWRlcihtYXAsIHRhYmxlLCByb3cgKyByZWZSb3cpKVxuICAgIHJlZlJvdyA9IHJvdyA9PSAwIHx8IHJvdyA9PSBtYXAuaGVpZ2h0ID8gbnVsbCA6IDA7XG4gIGZvciAobGV0IGNvbCA9IDAsIGluZGV4ID0gbWFwLndpZHRoICogcm93OyBjb2wgPCBtYXAud2lkdGg7IGNvbCsrLCBpbmRleCsrKSB7XG4gICAgaWYgKHJvdyA+IDAgJiYgcm93IDwgbWFwLmhlaWdodCAmJiBtYXAubWFwW2luZGV4XSA9PSBtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSkge1xuICAgICAgY29uc3QgcG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgICBjb25zdCBhdHRycyA9IHRhYmxlLm5vZGVBdChwb3MpLmF0dHJzO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0YWJsZVN0YXJ0ICsgcG9zLCBudWxsLCB7XG4gICAgICAgIC4uLmF0dHJzLFxuICAgICAgICByb3dzcGFuOiBhdHRycy5yb3dzcGFuICsgMVxuICAgICAgfSk7XG4gICAgICBjb2wgKz0gYXR0cnMuY29sc3BhbiAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSByZWZSb3cgPT0gbnVsbCA/IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5jZWxsIDogKF9hID0gdGFibGUubm9kZUF0KG1hcC5tYXBbaW5kZXggKyByZWZSb3cgKiBtYXAud2lkdGhdKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnR5cGU7XG4gICAgICBjb25zdCBub2RlID0gdHlwZSA9PSBudWxsID8gdm9pZCAwIDogdHlwZS5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICBpZiAobm9kZSkgY2VsbHMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgdHIuaW5zZXJ0KHJvd1BvcywgdGFibGVOb2RlVHlwZXModGFibGUudHlwZS5zY2hlbWEpLnJvdy5jcmVhdGUobnVsbCwgY2VsbHMpKTtcbiAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gYWRkUm93QmVmb3JlKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG4gICAgZGlzcGF0Y2goYWRkUm93KHN0YXRlLnRyLCByZWN0LCByZWN0LnRvcCkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYWRkUm93QWZ0ZXIoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKTtcbiAgICBkaXNwYXRjaChhZGRSb3coc3RhdGUudHIsIHJlY3QsIHJlY3QuYm90dG9tKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmVSb3codHIsIHsgbWFwLCB0YWJsZSwgdGFibGVTdGFydCB9LCByb3cpIHtcbiAgbGV0IHJvd1BvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93OyBpKyspIHJvd1BvcyArPSB0YWJsZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgY29uc3QgbmV4dFJvdyA9IHJvd1BvcyArIHRhYmxlLmNoaWxkKHJvdykubm9kZVNpemU7XG4gIGNvbnN0IG1hcEZyb20gPSB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoO1xuICB0ci5kZWxldGUocm93UG9zICsgdGFibGVTdGFydCwgbmV4dFJvdyArIHRhYmxlU3RhcnQpO1xuICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChsZXQgY29sID0gMCwgaW5kZXggPSByb3cgKiBtYXAud2lkdGg7IGNvbCA8IG1hcC53aWR0aDsgY29sKyssIGluZGV4KyspIHtcbiAgICBjb25zdCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICBpZiAoc2Vlbi5oYXMocG9zKSkgY29udGludWU7XG4gICAgc2Vlbi5hZGQocG9zKTtcbiAgICBpZiAocm93ID4gMCAmJiBwb3MgPT0gbWFwLm1hcFtpbmRleCAtIG1hcC53aWR0aF0pIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gdGFibGUubm9kZUF0KHBvcykuYXR0cnM7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIHRhYmxlU3RhcnQpLCBudWxsLCB7XG4gICAgICAgIC4uLmF0dHJzLFxuICAgICAgICByb3dzcGFuOiBhdHRycy5yb3dzcGFuIC0gMVxuICAgICAgfSk7XG4gICAgICBjb2wgKz0gYXR0cnMuY29sc3BhbiAtIDE7XG4gICAgfSBlbHNlIGlmIChyb3cgPCBtYXAuaGVpZ2h0ICYmIHBvcyA9PSBtYXAubWFwW2luZGV4ICsgbWFwLndpZHRoXSkge1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuICAgICAgY29uc3QgYXR0cnMgPSBjZWxsLmF0dHJzO1xuICAgICAgY29uc3QgY29weSA9IGNlbGwudHlwZS5jcmVhdGUoXG4gICAgICAgIHsgLi4uYXR0cnMsIHJvd3NwYW46IGNlbGwuYXR0cnMucm93c3BhbiAtIDEgfSxcbiAgICAgICAgY2VsbC5jb250ZW50XG4gICAgICApO1xuICAgICAgY29uc3QgbmV3UG9zID0gbWFwLnBvc2l0aW9uQXQocm93ICsgMSwgY29sLCB0YWJsZSk7XG4gICAgICB0ci5pbnNlcnQodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAodGFibGVTdGFydCArIG5ld1BvcyksIGNvcHkpO1xuICAgICAgY29sICs9IGF0dHJzLmNvbHNwYW4gLSAxO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVsZXRlUm93KHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSksIHRyID0gc3RhdGUudHI7XG4gICAgaWYgKHJlY3QudG9wID09IDAgJiYgcmVjdC5ib3R0b20gPT0gcmVjdC5tYXAuaGVpZ2h0KSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IHJlY3QuYm90dG9tIC0gMTsgOyBpLS0pIHtcbiAgICAgIHJlbW92ZVJvdyh0ciwgcmVjdCwgaSk7XG4gICAgICBpZiAoaSA9PSByZWN0LnRvcCkgYnJlYWs7XG4gICAgICBjb25zdCB0YWJsZSA9IHJlY3QudGFibGVTdGFydCA/IHRyLmRvYy5ub2RlQXQocmVjdC50YWJsZVN0YXJ0IC0gMSkgOiB0ci5kb2M7XG4gICAgICBpZiAoIXRhYmxlKSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJObyB0YWJsZSBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJlY3QudGFibGUgPSB0YWJsZTtcbiAgICAgIHJlY3QubWFwID0gVGFibGVNYXAuZ2V0KHJlY3QudGFibGUpO1xuICAgIH1cbiAgICBkaXNwYXRjaCh0cik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0VtcHR5KGNlbGwpIHtcbiAgY29uc3QgYyA9IGNlbGwuY29udGVudDtcbiAgcmV0dXJuIGMuY2hpbGRDb3VudCA9PSAxICYmIGMuY2hpbGQoMCkuaXNUZXh0YmxvY2sgJiYgYy5jaGlsZCgwKS5jaGlsZENvdW50ID09IDA7XG59XG5mdW5jdGlvbiBjZWxsc092ZXJsYXBSZWN0YW5nbGUoeyB3aWR0aCwgaGVpZ2h0LCBtYXAgfSwgcmVjdCkge1xuICBsZXQgaW5kZXhUb3AgPSByZWN0LnRvcCAqIHdpZHRoICsgcmVjdC5sZWZ0LCBpbmRleExlZnQgPSBpbmRleFRvcDtcbiAgbGV0IGluZGV4Qm90dG9tID0gKHJlY3QuYm90dG9tIC0gMSkgKiB3aWR0aCArIHJlY3QubGVmdCwgaW5kZXhSaWdodCA9IGluZGV4VG9wICsgKHJlY3QucmlnaHQgLSByZWN0LmxlZnQgLSAxKTtcbiAgZm9yIChsZXQgaSA9IHJlY3QudG9wOyBpIDwgcmVjdC5ib3R0b207IGkrKykge1xuICAgIGlmIChyZWN0LmxlZnQgPiAwICYmIG1hcFtpbmRleExlZnRdID09IG1hcFtpbmRleExlZnQgLSAxXSB8fCByZWN0LnJpZ2h0IDwgd2lkdGggJiYgbWFwW2luZGV4UmlnaHRdID09IG1hcFtpbmRleFJpZ2h0ICsgMV0pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpbmRleExlZnQgKz0gd2lkdGg7XG4gICAgaW5kZXhSaWdodCArPSB3aWR0aDtcbiAgfVxuICBmb3IgKGxldCBpID0gcmVjdC5sZWZ0OyBpIDwgcmVjdC5yaWdodDsgaSsrKSB7XG4gICAgaWYgKHJlY3QudG9wID4gMCAmJiBtYXBbaW5kZXhUb3BdID09IG1hcFtpbmRleFRvcCAtIHdpZHRoXSB8fCByZWN0LmJvdHRvbSA8IGhlaWdodCAmJiBtYXBbaW5kZXhCb3R0b21dID09IG1hcFtpbmRleEJvdHRvbSArIHdpZHRoXSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGluZGV4VG9wKys7XG4gICAgaW5kZXhCb3R0b20rKztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBtZXJnZUNlbGxzKHN0YXRlLCBkaXNwYXRjaCkge1xuICBjb25zdCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIGlmICghKHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pIHx8IHNlbC4kYW5jaG9yQ2VsbC5wb3MgPT0gc2VsLiRoZWFkQ2VsbC5wb3MpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKSwgeyBtYXAgfSA9IHJlY3Q7XG4gIGlmIChjZWxsc092ZXJsYXBSZWN0YW5nbGUobWFwLCByZWN0KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50Mi5lbXB0eTtcbiAgICBsZXQgbWVyZ2VkUG9zO1xuICAgIGxldCBtZXJnZWRDZWxsO1xuICAgIGZvciAobGV0IHJvdyA9IHJlY3QudG9wOyByb3cgPCByZWN0LmJvdHRvbTsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IHJlY3QubGVmdDsgY29sIDwgcmVjdC5yaWdodDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbFBvcyA9IG1hcC5tYXBbcm93ICogbWFwLndpZHRoICsgY29sXTtcbiAgICAgICAgY29uc3QgY2VsbCA9IHJlY3QudGFibGUubm9kZUF0KGNlbGxQb3MpO1xuICAgICAgICBpZiAoc2VlbltjZWxsUG9zXSB8fCAhY2VsbCkgY29udGludWU7XG4gICAgICAgIHNlZW5bY2VsbFBvc10gPSB0cnVlO1xuICAgICAgICBpZiAobWVyZ2VkUG9zID09IG51bGwpIHtcbiAgICAgICAgICBtZXJnZWRQb3MgPSBjZWxsUG9zO1xuICAgICAgICAgIG1lcmdlZENlbGwgPSBjZWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghaXNFbXB0eShjZWxsKSkgY29udGVudCA9IGNvbnRlbnQuYXBwZW5kKGNlbGwuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgbWFwcGVkID0gdHIubWFwcGluZy5tYXAoY2VsbFBvcyArIHJlY3QudGFibGVTdGFydCk7XG4gICAgICAgICAgdHIuZGVsZXRlKG1hcHBlZCwgbWFwcGVkICsgY2VsbC5ub2RlU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1lcmdlZFBvcyA9PSBudWxsIHx8IG1lcmdlZENlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRyLnNldE5vZGVNYXJrdXAobWVyZ2VkUG9zICsgcmVjdC50YWJsZVN0YXJ0LCBudWxsLCB7XG4gICAgICAuLi5hZGRDb2xTcGFuKFxuICAgICAgICBtZXJnZWRDZWxsLmF0dHJzLFxuICAgICAgICBtZXJnZWRDZWxsLmF0dHJzLmNvbHNwYW4sXG4gICAgICAgIHJlY3QucmlnaHQgLSByZWN0LmxlZnQgLSBtZXJnZWRDZWxsLmF0dHJzLmNvbHNwYW5cbiAgICAgICksXG4gICAgICByb3dzcGFuOiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgfSk7XG4gICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgY29uc3QgZW5kID0gbWVyZ2VkUG9zICsgMSArIG1lcmdlZENlbGwuY29udGVudC5zaXplO1xuICAgICAgY29uc3Qgc3RhcnQgPSBpc0VtcHR5KG1lcmdlZENlbGwpID8gbWVyZ2VkUG9zICsgMSA6IGVuZDtcbiAgICAgIHRyLnJlcGxhY2VXaXRoKHN0YXJ0ICsgcmVjdC50YWJsZVN0YXJ0LCBlbmQgKyByZWN0LnRhYmxlU3RhcnQsIGNvbnRlbnQpO1xuICAgIH1cbiAgICB0ci5zZXRTZWxlY3Rpb24oXG4gICAgICBuZXcgQ2VsbFNlbGVjdGlvbih0ci5kb2MucmVzb2x2ZShtZXJnZWRQb3MgKyByZWN0LnRhYmxlU3RhcnQpKVxuICAgICk7XG4gICAgZGlzcGF0Y2godHIpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc3BsaXRDZWxsKHN0YXRlLCBkaXNwYXRjaCkge1xuICBjb25zdCBub2RlVHlwZXMgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpO1xuICByZXR1cm4gc3BsaXRDZWxsV2l0aFR5cGUoKHsgbm9kZSB9KSA9PiB7XG4gICAgcmV0dXJuIG5vZGVUeXBlc1tub2RlLnR5cGUuc3BlYy50YWJsZVJvbGVdO1xuICB9KShzdGF0ZSwgZGlzcGF0Y2gpO1xufVxuZnVuY3Rpb24gc3BsaXRDZWxsV2l0aFR5cGUoZ2V0Q2VsbFR5cGUpIHtcbiAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBjZWxsTm9kZTtcbiAgICBsZXQgY2VsbFBvcztcbiAgICBpZiAoIShzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSkge1xuICAgICAgY2VsbE5vZGUgPSBjZWxsV3JhcHBpbmcoc2VsLiRmcm9tKTtcbiAgICAgIGlmICghY2VsbE5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgIGNlbGxQb3MgPSAoX2EgPSBjZWxsQXJvdW5kKHNlbC4kZnJvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWwuJGFuY2hvckNlbGwucG9zICE9IHNlbC4kaGVhZENlbGwucG9zKSByZXR1cm4gZmFsc2U7XG4gICAgICBjZWxsTm9kZSA9IHNlbC4kYW5jaG9yQ2VsbC5ub2RlQWZ0ZXI7XG4gICAgICBjZWxsUG9zID0gc2VsLiRhbmNob3JDZWxsLnBvcztcbiAgICB9XG4gICAgaWYgKGNlbGxOb2RlID09IG51bGwgfHwgY2VsbFBvcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjZWxsTm9kZS5hdHRycy5jb2xzcGFuID09IDEgJiYgY2VsbE5vZGUuYXR0cnMucm93c3BhbiA9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgbGV0IGJhc2VBdHRycyA9IGNlbGxOb2RlLmF0dHJzO1xuICAgICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICAgIGNvbnN0IGNvbHdpZHRoID0gYmFzZUF0dHJzLmNvbHdpZHRoO1xuICAgICAgaWYgKGJhc2VBdHRycy5yb3dzcGFuID4gMSkgYmFzZUF0dHJzID0geyAuLi5iYXNlQXR0cnMsIHJvd3NwYW46IDEgfTtcbiAgICAgIGlmIChiYXNlQXR0cnMuY29sc3BhbiA+IDEpIGJhc2VBdHRycyA9IHsgLi4uYmFzZUF0dHJzLCBjb2xzcGFuOiAxIH07XG4gICAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdC5yaWdodCAtIHJlY3QubGVmdDsgaSsrKVxuICAgICAgICBhdHRycy5wdXNoKFxuICAgICAgICAgIGNvbHdpZHRoID8ge1xuICAgICAgICAgICAgLi4uYmFzZUF0dHJzLFxuICAgICAgICAgICAgY29sd2lkdGg6IGNvbHdpZHRoICYmIGNvbHdpZHRoW2ldID8gW2NvbHdpZHRoW2ldXSA6IG51bGxcbiAgICAgICAgICB9IDogYmFzZUF0dHJzXG4gICAgICAgICk7XG4gICAgICBsZXQgbGFzdENlbGw7XG4gICAgICBmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSB7XG4gICAgICAgIGxldCBwb3MgPSByZWN0Lm1hcC5wb3NpdGlvbkF0KHJvdywgcmVjdC5sZWZ0LCByZWN0LnRhYmxlKTtcbiAgICAgICAgaWYgKHJvdyA9PSByZWN0LnRvcCkgcG9zICs9IGNlbGxOb2RlLm5vZGVTaXplO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSByZWN0LmxlZnQsIGkgPSAwOyBjb2wgPCByZWN0LnJpZ2h0OyBjb2wrKywgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvbCA9PSByZWN0LmxlZnQgJiYgcm93ID09IHJlY3QudG9wKSBjb250aW51ZTtcbiAgICAgICAgICB0ci5pbnNlcnQoXG4gICAgICAgICAgICBsYXN0Q2VsbCA9IHRyLm1hcHBpbmcubWFwKHBvcyArIHJlY3QudGFibGVTdGFydCwgMSksXG4gICAgICAgICAgICBnZXRDZWxsVHlwZSh7IG5vZGU6IGNlbGxOb2RlLCByb3csIGNvbCB9KS5jcmVhdGVBbmRGaWxsKGF0dHJzW2ldKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgIGNlbGxQb3MsXG4gICAgICAgIGdldENlbGxUeXBlKHsgbm9kZTogY2VsbE5vZGUsIHJvdzogcmVjdC50b3AsIGNvbDogcmVjdC5sZWZ0IH0pLFxuICAgICAgICBhdHRyc1swXVxuICAgICAgKTtcbiAgICAgIGlmIChzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKVxuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgbmV3IENlbGxTZWxlY3Rpb24oXG4gICAgICAgICAgICB0ci5kb2MucmVzb2x2ZShzZWwuJGFuY2hvckNlbGwucG9zKSxcbiAgICAgICAgICAgIGxhc3RDZWxsID8gdHIuZG9jLnJlc29sdmUobGFzdENlbGwpIDogdm9pZCAwXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldENlbGxBdHRyKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCAkY2VsbCA9IHNlbGVjdGlvbkNlbGwoc3RhdGUpO1xuICAgIGlmICgkY2VsbC5ub2RlQWZ0ZXIuYXR0cnNbbmFtZV0gPT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pXG4gICAgICAgIHN0YXRlLnNlbGVjdGlvbi5mb3JFYWNoQ2VsbCgobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuYXR0cnNbbmFtZV0gIT09IHZhbHVlKVxuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIG51bGwsIHtcbiAgICAgICAgICAgICAgLi4ubm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgW25hbWVdOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICB0ci5zZXROb2RlTWFya3VwKCRjZWxsLnBvcywgbnVsbCwge1xuICAgICAgICAgIC4uLiRjZWxsLm5vZGVBZnRlci5hdHRycyxcbiAgICAgICAgICBbbmFtZV06IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRfdG9nZ2xlSGVhZGVyKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgY29uc3QgdHlwZXMgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpO1xuICAgICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSksIHRyID0gc3RhdGUudHI7XG4gICAgICBjb25zdCBjZWxscyA9IHJlY3QubWFwLmNlbGxzSW5SZWN0KFxuICAgICAgICB0eXBlID09IFwiY29sdW1uXCIgPyB7XG4gICAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICByaWdodDogcmVjdC5yaWdodCxcbiAgICAgICAgICBib3R0b206IHJlY3QubWFwLmhlaWdodFxuICAgICAgICB9IDogdHlwZSA9PSBcInJvd1wiID8ge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgICByaWdodDogcmVjdC5tYXAud2lkdGgsXG4gICAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbVxuICAgICAgICB9IDogcmVjdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG5vZGVzID0gY2VsbHMubWFwKChwb3MpID0+IHJlY3QudGFibGUubm9kZUF0KHBvcykpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKG5vZGVzW2ldLnR5cGUgPT0gdHlwZXMuaGVhZGVyX2NlbGwpXG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgICAgIHJlY3QudGFibGVTdGFydCArIGNlbGxzW2ldLFxuICAgICAgICAgICAgdHlwZXMuY2VsbCxcbiAgICAgICAgICAgIG5vZGVzW2ldLmF0dHJzXG4gICAgICAgICAgKTtcbiAgICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPT0gMClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICAgICAgcmVjdC50YWJsZVN0YXJ0ICsgY2VsbHNbaV0sXG4gICAgICAgICAgICB0eXBlcy5oZWFkZXJfY2VsbCxcbiAgICAgICAgICAgIG5vZGVzW2ldLmF0dHJzXG4gICAgICAgICAgKTtcbiAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiBpc0hlYWRlckVuYWJsZWRCeVR5cGUodHlwZSwgcmVjdCwgdHlwZXMpIHtcbiAgY29uc3QgY2VsbFBvc2l0aW9ucyA9IHJlY3QubWFwLmNlbGxzSW5SZWN0KHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICByaWdodDogdHlwZSA9PSBcInJvd1wiID8gcmVjdC5tYXAud2lkdGggOiAxLFxuICAgIGJvdHRvbTogdHlwZSA9PSBcImNvbHVtblwiID8gcmVjdC5tYXAuaGVpZ2h0IDogMVxuICB9KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2VsbCA9IHJlY3QudGFibGUubm9kZUF0KGNlbGxQb3NpdGlvbnNbaV0pO1xuICAgIGlmIChjZWxsICYmIGNlbGwudHlwZSAhPT0gdHlwZXMuaGVhZGVyX2NlbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0b2dnbGVIZWFkZXIodHlwZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IHVzZURlcHJlY2F0ZWRMb2dpYzogZmFsc2UgfTtcbiAgaWYgKG9wdGlvbnMudXNlRGVwcmVjYXRlZExvZ2ljKSByZXR1cm4gZGVwcmVjYXRlZF90b2dnbGVIZWFkZXIodHlwZSk7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGNvbnN0IHR5cGVzID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgY29uc3QgaXNIZWFkZXJSb3dFbmFibGVkID0gaXNIZWFkZXJFbmFibGVkQnlUeXBlKFwicm93XCIsIHJlY3QsIHR5cGVzKTtcbiAgICAgIGNvbnN0IGlzSGVhZGVyQ29sdW1uRW5hYmxlZCA9IGlzSGVhZGVyRW5hYmxlZEJ5VHlwZShcbiAgICAgICAgXCJjb2x1bW5cIixcbiAgICAgICAgcmVjdCxcbiAgICAgICAgdHlwZXNcbiAgICAgICk7XG4gICAgICBjb25zdCBpc0hlYWRlckVuYWJsZWQgPSB0eXBlID09PSBcImNvbHVtblwiID8gaXNIZWFkZXJSb3dFbmFibGVkIDogdHlwZSA9PT0gXCJyb3dcIiA/IGlzSGVhZGVyQ29sdW1uRW5hYmxlZCA6IGZhbHNlO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRzQXQgPSBpc0hlYWRlckVuYWJsZWQgPyAxIDogMDtcbiAgICAgIGNvbnN0IGNlbGxzUmVjdCA9IHR5cGUgPT0gXCJjb2x1bW5cIiA/IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiBzZWxlY3Rpb25TdGFydHNBdCxcbiAgICAgICAgcmlnaHQ6IDEsXG4gICAgICAgIGJvdHRvbTogcmVjdC5tYXAuaGVpZ2h0XG4gICAgICB9IDogdHlwZSA9PSBcInJvd1wiID8ge1xuICAgICAgICBsZWZ0OiBzZWxlY3Rpb25TdGFydHNBdCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogcmVjdC5tYXAud2lkdGgsXG4gICAgICAgIGJvdHRvbTogMVxuICAgICAgfSA6IHJlY3Q7XG4gICAgICBjb25zdCBuZXdUeXBlID0gdHlwZSA9PSBcImNvbHVtblwiID8gaXNIZWFkZXJDb2x1bW5FbmFibGVkID8gdHlwZXMuY2VsbCA6IHR5cGVzLmhlYWRlcl9jZWxsIDogdHlwZSA9PSBcInJvd1wiID8gaXNIZWFkZXJSb3dFbmFibGVkID8gdHlwZXMuY2VsbCA6IHR5cGVzLmhlYWRlcl9jZWxsIDogdHlwZXMuY2VsbDtcbiAgICAgIHJlY3QubWFwLmNlbGxzSW5SZWN0KGNlbGxzUmVjdCkuZm9yRWFjaCgocmVsYXRpdmVDZWxsUG9zKSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxQb3MgPSByZWxhdGl2ZUNlbGxQb3MgKyByZWN0LnRhYmxlU3RhcnQ7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0ci5kb2Mubm9kZUF0KGNlbGxQb3MpO1xuICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAoY2VsbFBvcywgbmV3VHlwZSwgY2VsbC5hdHRycyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbnZhciB0b2dnbGVIZWFkZXJSb3cgPSB0b2dnbGVIZWFkZXIoXCJyb3dcIiwge1xuICB1c2VEZXByZWNhdGVkTG9naWM6IHRydWVcbn0pO1xudmFyIHRvZ2dsZUhlYWRlckNvbHVtbiA9IHRvZ2dsZUhlYWRlcihcImNvbHVtblwiLCB7XG4gIHVzZURlcHJlY2F0ZWRMb2dpYzogdHJ1ZVxufSk7XG52YXIgdG9nZ2xlSGVhZGVyQ2VsbCA9IHRvZ2dsZUhlYWRlcihcImNlbGxcIiwge1xuICB1c2VEZXByZWNhdGVkTG9naWM6IHRydWVcbn0pO1xuZnVuY3Rpb24gZmluZE5leHRDZWxsKCRjZWxsLCBkaXIpIHtcbiAgaWYgKGRpciA8IDApIHtcbiAgICBjb25zdCBiZWZvcmUgPSAkY2VsbC5ub2RlQmVmb3JlO1xuICAgIGlmIChiZWZvcmUpIHJldHVybiAkY2VsbC5wb3MgLSBiZWZvcmUubm9kZVNpemU7XG4gICAgZm9yIChsZXQgcm93ID0gJGNlbGwuaW5kZXgoLTEpIC0gMSwgcm93RW5kID0gJGNlbGwuYmVmb3JlKCk7IHJvdyA+PSAwOyByb3ctLSkge1xuICAgICAgY29uc3Qgcm93Tm9kZSA9ICRjZWxsLm5vZGUoLTEpLmNoaWxkKHJvdyk7XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSByb3dOb2RlLmxhc3RDaGlsZDtcbiAgICAgIGlmIChsYXN0Q2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHJvd0VuZCAtIDEgLSBsYXN0Q2hpbGQubm9kZVNpemU7XG4gICAgICB9XG4gICAgICByb3dFbmQgLT0gcm93Tm9kZS5ub2RlU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRjZWxsLmluZGV4KCkgPCAkY2VsbC5wYXJlbnQuY2hpbGRDb3VudCAtIDEpIHtcbiAgICAgIHJldHVybiAkY2VsbC5wb3MgKyAkY2VsbC5ub2RlQWZ0ZXIubm9kZVNpemU7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSk7XG4gICAgZm9yIChsZXQgcm93ID0gJGNlbGwuaW5kZXhBZnRlcigtMSksIHJvd1N0YXJ0ID0gJGNlbGwuYWZ0ZXIoKTsgcm93IDwgdGFibGUuY2hpbGRDb3VudDsgcm93KyspIHtcbiAgICAgIGNvbnN0IHJvd05vZGUgPSB0YWJsZS5jaGlsZChyb3cpO1xuICAgICAgaWYgKHJvd05vZGUuY2hpbGRDb3VudCkgcmV0dXJuIHJvd1N0YXJ0ICsgMTtcbiAgICAgIHJvd1N0YXJ0ICs9IHJvd05vZGUubm9kZVNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ29Ub05leHRDZWxsKGRpcmVjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY2VsbCA9IGZpbmROZXh0Q2VsbChzZWxlY3Rpb25DZWxsKHN0YXRlKSwgZGlyZWN0aW9uKTtcbiAgICBpZiAoY2VsbCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBjb25zdCAkY2VsbCA9IHN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuICAgICAgZGlzcGF0Y2goXG4gICAgICAgIHN0YXRlLnRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uMi5iZXR3ZWVuKCRjZWxsLCBtb3ZlQ2VsbEZvcndhcmQoJGNlbGwpKSkuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVUYWJsZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgY29uc3QgJHBvcyA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yO1xuICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+IDA7IGQtLSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZCk7XG4gICAgaWYgKG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcInRhYmxlXCIpIHtcbiAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgc3RhdGUudHIuZGVsZXRlKCRwb3MuYmVmb3JlKGQpLCAkcG9zLmFmdGVyKGQpKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVsZXRlQ2VsbFNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoIShzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgIGNvbnN0IGJhc2VDb250ZW50ID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKS5jZWxsLmNyZWF0ZUFuZEZpbGwoKS5jb250ZW50O1xuICAgIHNlbC5mb3JFYWNoQ2VsbCgoY2VsbCwgcG9zKSA9PiB7XG4gICAgICBpZiAoIWNlbGwuY29udGVudC5lcShiYXNlQ29udGVudCkpXG4gICAgICAgIHRyLnJlcGxhY2UoXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAocG9zICsgMSksXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAocG9zICsgY2VsbC5ub2RlU2l6ZSAtIDEpLFxuICAgICAgICAgIG5ldyBTbGljZTIoYmFzZUNvbnRlbnQsIDAsIDApXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgaWYgKHRyLmRvY0NoYW5nZWQpIGRpc3BhdGNoKHRyKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1vdmVUYWJsZVJvdzIob3B0aW9ucykge1xuICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyb206IG9yaWdpbkluZGV4LFxuICAgICAgdG86IHRhcmdldEluZGV4LFxuICAgICAgc2VsZWN0ID0gdHJ1ZSxcbiAgICAgIHBvcyA9IHN0YXRlLnNlbGVjdGlvbi5mcm9tXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICBpZiAobW92ZVJvdyh7IHRyLCBvcmlnaW5JbmRleCwgdGFyZ2V0SW5kZXgsIHNlbGVjdCwgcG9zIH0pKSB7XG4gICAgICBkaXNwYXRjaCA9PSBudWxsID8gdm9pZCAwIDogZGlzcGF0Y2godHIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVUYWJsZUNvbHVtbjIob3B0aW9ucykge1xuICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyb206IG9yaWdpbkluZGV4LFxuICAgICAgdG86IHRhcmdldEluZGV4LFxuICAgICAgc2VsZWN0ID0gdHJ1ZSxcbiAgICAgIHBvcyA9IHN0YXRlLnNlbGVjdGlvbi5mcm9tXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICBpZiAobW92ZUNvbHVtbih7IHRyLCBvcmlnaW5JbmRleCwgdGFyZ2V0SW5kZXgsIHNlbGVjdCwgcG9zIH0pKSB7XG4gICAgICBkaXNwYXRjaCA9PSBudWxsID8gdm9pZCAwIDogZGlzcGF0Y2godHIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLy8gc3JjL2NvcHlwYXN0ZS50c1xuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQzLCBTbGljZSBhcyBTbGljZTMgfSBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gXCJwcm9zZW1pcnJvci10cmFuc2Zvcm1cIjtcbmZ1bmN0aW9uIHBhc3RlZENlbGxzKHNsaWNlKSB7XG4gIGlmICghc2xpY2Uuc2l6ZSkgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gIHdoaWxlIChjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiAob3BlblN0YXJ0ID4gMCAmJiBvcGVuRW5kID4gMCB8fCBjb250ZW50LmNoaWxkKDApLnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJ0YWJsZVwiKSkge1xuICAgIG9wZW5TdGFydC0tO1xuICAgIG9wZW5FbmQtLTtcbiAgICBjb250ZW50ID0gY29udGVudC5jaGlsZCgwKS5jb250ZW50O1xuICB9XG4gIGNvbnN0IGZpcnN0ID0gY29udGVudC5jaGlsZCgwKTtcbiAgY29uc3Qgcm9sZSA9IGZpcnN0LnR5cGUuc3BlYy50YWJsZVJvbGU7XG4gIGNvbnN0IHNjaGVtYSA9IGZpcnN0LnR5cGUuc2NoZW1hLCByb3dzID0gW107XG4gIGlmIChyb2xlID09IFwicm93XCIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICBsZXQgY2VsbHMgPSBjb250ZW50LmNoaWxkKGkpLmNvbnRlbnQ7XG4gICAgICBjb25zdCBsZWZ0ID0gaSA/IDAgOiBNYXRoLm1heCgwLCBvcGVuU3RhcnQgLSAxKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gaSA8IGNvbnRlbnQuY2hpbGRDb3VudCAtIDEgPyAwIDogTWF0aC5tYXgoMCwgb3BlbkVuZCAtIDEpO1xuICAgICAgaWYgKGxlZnQgfHwgcmlnaHQpXG4gICAgICAgIGNlbGxzID0gZml0U2xpY2UoXG4gICAgICAgICAgdGFibGVOb2RlVHlwZXMoc2NoZW1hKS5yb3csXG4gICAgICAgICAgbmV3IFNsaWNlMyhjZWxscywgbGVmdCwgcmlnaHQpXG4gICAgICAgICkuY29udGVudDtcbiAgICAgIHJvd3MucHVzaChjZWxscyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpIHtcbiAgICByb3dzLnB1c2goXG4gICAgICBvcGVuU3RhcnQgfHwgb3BlbkVuZCA/IGZpdFNsaWNlKFxuICAgICAgICB0YWJsZU5vZGVUeXBlcyhzY2hlbWEpLnJvdyxcbiAgICAgICAgbmV3IFNsaWNlMyhjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpXG4gICAgICApLmNvbnRlbnQgOiBjb250ZW50XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZW5zdXJlUmVjdGFuZ3VsYXIoc2NoZW1hLCByb3dzKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZVJlY3Rhbmd1bGFyKHNjaGVtYSwgcm93cykge1xuICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gcm93c1tpXTtcbiAgICBmb3IgKGxldCBqID0gcm93LmNoaWxkQ291bnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgY29uc3QgeyByb3dzcGFuLCBjb2xzcGFuIH0gPSByb3cuY2hpbGQoaikuYXR0cnM7XG4gICAgICBmb3IgKGxldCByID0gaTsgciA8IGkgKyByb3dzcGFuOyByKyspXG4gICAgICAgIHdpZHRoc1tyXSA9ICh3aWR0aHNbcl0gfHwgMCkgKyBjb2xzcGFuO1xuICAgIH1cbiAgfVxuICBsZXQgd2lkdGggPSAwO1xuICBmb3IgKGxldCByID0gMDsgciA8IHdpZHRocy5sZW5ndGg7IHIrKykgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgd2lkdGhzW3JdKTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB3aWR0aHMubGVuZ3RoOyByKyspIHtcbiAgICBpZiAociA+PSByb3dzLmxlbmd0aCkgcm93cy5wdXNoKEZyYWdtZW50My5lbXB0eSk7XG4gICAgaWYgKHdpZHRoc1tyXSA8IHdpZHRoKSB7XG4gICAgICBjb25zdCBlbXB0eSA9IHRhYmxlTm9kZVR5cGVzKHNjaGVtYSkuY2VsbC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICBjb25zdCBjZWxscyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IHdpZHRoc1tyXTsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgY2VsbHMucHVzaChlbXB0eSk7XG4gICAgICB9XG4gICAgICByb3dzW3JdID0gcm93c1tyXS5hcHBlbmQoRnJhZ21lbnQzLmZyb20oY2VsbHMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaGVpZ2h0OiByb3dzLmxlbmd0aCwgd2lkdGgsIHJvd3MgfTtcbn1cbmZ1bmN0aW9uIGZpdFNsaWNlKG5vZGVUeXBlLCBzbGljZSkge1xuICBjb25zdCBub2RlID0gbm9kZVR5cGUuY3JlYXRlQW5kRmlsbCgpO1xuICBjb25zdCB0ciA9IG5ldyBUcmFuc2Zvcm0obm9kZSkucmVwbGFjZSgwLCBub2RlLmNvbnRlbnQuc2l6ZSwgc2xpY2UpO1xuICByZXR1cm4gdHIuZG9jO1xufVxuZnVuY3Rpb24gY2xpcENlbGxzKHsgd2lkdGgsIGhlaWdodCwgcm93cyB9LCBuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gIGlmICh3aWR0aCAhPSBuZXdXaWR0aCkge1xuICAgIGNvbnN0IGFkZGVkID0gW107XG4gICAgY29uc3QgbmV3Um93cyA9IFtdO1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3MubGVuZ3RoOyByb3crKykge1xuICAgICAgY29uc3QgZnJhZyA9IHJvd3Nbcm93XSwgY2VsbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGNvbCA9IGFkZGVkW3Jvd10gfHwgMCwgaSA9IDA7IGNvbCA8IG5ld1dpZHRoOyBpKyspIHtcbiAgICAgICAgbGV0IGNlbGwgPSBmcmFnLmNoaWxkKGkgJSBmcmFnLmNoaWxkQ291bnQpO1xuICAgICAgICBpZiAoY29sICsgY2VsbC5hdHRycy5jb2xzcGFuID4gbmV3V2lkdGgpXG4gICAgICAgICAgY2VsbCA9IGNlbGwudHlwZS5jcmVhdGVDaGVja2VkKFxuICAgICAgICAgICAgcmVtb3ZlQ29sU3BhbihcbiAgICAgICAgICAgICAgY2VsbC5hdHRycyxcbiAgICAgICAgICAgICAgY2VsbC5hdHRycy5jb2xzcGFuLFxuICAgICAgICAgICAgICBjb2wgKyBjZWxsLmF0dHJzLmNvbHNwYW4gLSBuZXdXaWR0aFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNlbGwuY29udGVudFxuICAgICAgICAgICk7XG4gICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgIGNvbCArPSBjZWxsLmF0dHJzLmNvbHNwYW47XG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgY2VsbC5hdHRycy5yb3dzcGFuOyBqKyspXG4gICAgICAgICAgYWRkZWRbcm93ICsgal0gPSAoYWRkZWRbcm93ICsgal0gfHwgMCkgKyBjZWxsLmF0dHJzLmNvbHNwYW47XG4gICAgICB9XG4gICAgICBuZXdSb3dzLnB1c2goRnJhZ21lbnQzLmZyb20oY2VsbHMpKTtcbiAgICB9XG4gICAgcm93cyA9IG5ld1Jvd3M7XG4gICAgd2lkdGggPSBuZXdXaWR0aDtcbiAgfVxuICBpZiAoaGVpZ2h0ICE9IG5ld0hlaWdodCkge1xuICAgIGNvbnN0IG5ld1Jvd3MgPSBbXTtcbiAgICBmb3IgKGxldCByb3cgPSAwLCBpID0gMDsgcm93IDwgbmV3SGVpZ2h0OyByb3crKywgaSsrKSB7XG4gICAgICBjb25zdCBjZWxscyA9IFtdLCBzb3VyY2UgPSByb3dzW2kgJSBoZWlnaHRdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzb3VyY2UuY2hpbGRDb3VudDsgaisrKSB7XG4gICAgICAgIGxldCBjZWxsID0gc291cmNlLmNoaWxkKGopO1xuICAgICAgICBpZiAocm93ICsgY2VsbC5hdHRycy5yb3dzcGFuID4gbmV3SGVpZ2h0KVxuICAgICAgICAgIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICAgICAgICByb3dzcGFuOiBNYXRoLm1heCgxLCBuZXdIZWlnaHQgLSBjZWxsLmF0dHJzLnJvd3NwYW4pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2VsbC5jb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgIH1cbiAgICAgIG5ld1Jvd3MucHVzaChGcmFnbWVudDMuZnJvbShjZWxscykpO1xuICAgIH1cbiAgICByb3dzID0gbmV3Um93cztcbiAgICBoZWlnaHQgPSBuZXdIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgcm93cyB9O1xufVxuZnVuY3Rpb24gZ3Jvd1RhYmxlKHRyLCBtYXAsIHRhYmxlLCBzdGFydCwgd2lkdGgsIGhlaWdodCwgbWFwRnJvbSkge1xuICBjb25zdCBzY2hlbWEgPSB0ci5kb2MudHlwZS5zY2hlbWE7XG4gIGNvbnN0IHR5cGVzID0gdGFibGVOb2RlVHlwZXMoc2NoZW1hKTtcbiAgbGV0IGVtcHR5O1xuICBsZXQgZW1wdHlIZWFkO1xuICBpZiAod2lkdGggPiBtYXAud2lkdGgpIHtcbiAgICBmb3IgKGxldCByb3cgPSAwLCByb3dFbmQgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuICAgICAgY29uc3Qgcm93Tm9kZSA9IHRhYmxlLmNoaWxkKHJvdyk7XG4gICAgICByb3dFbmQgKz0gcm93Tm9kZS5ub2RlU2l6ZTtcbiAgICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgICBsZXQgYWRkO1xuICAgICAgaWYgKHJvd05vZGUubGFzdENoaWxkID09IG51bGwgfHwgcm93Tm9kZS5sYXN0Q2hpbGQudHlwZSA9PSB0eXBlcy5jZWxsKVxuICAgICAgICBhZGQgPSBlbXB0eSB8fCAoZW1wdHkgPSB0eXBlcy5jZWxsLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICBlbHNlIGFkZCA9IGVtcHR5SGVhZCB8fCAoZW1wdHlIZWFkID0gdHlwZXMuaGVhZGVyX2NlbGwuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgIGZvciAobGV0IGkgPSBtYXAud2lkdGg7IGkgPCB3aWR0aDsgaSsrKSBjZWxscy5wdXNoKGFkZCk7XG4gICAgICB0ci5pbnNlcnQodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocm93RW5kIC0gMSArIHN0YXJ0KSwgY2VsbHMpO1xuICAgIH1cbiAgfVxuICBpZiAoaGVpZ2h0ID4gbWFwLmhlaWdodCkge1xuICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0MiA9IChtYXAuaGVpZ2h0IC0gMSkgKiBtYXAud2lkdGg7IGkgPCBNYXRoLm1heChtYXAud2lkdGgsIHdpZHRoKTsgaSsrKSB7XG4gICAgICBjb25zdCBoZWFkZXIgPSBpID49IG1hcC53aWR0aCA/IGZhbHNlIDogdGFibGUubm9kZUF0KG1hcC5tYXBbc3RhcnQyICsgaV0pLnR5cGUgPT0gdHlwZXMuaGVhZGVyX2NlbGw7XG4gICAgICBjZWxscy5wdXNoKFxuICAgICAgICBoZWFkZXIgPyBlbXB0eUhlYWQgfHwgKGVtcHR5SGVhZCA9IHR5cGVzLmhlYWRlcl9jZWxsLmNyZWF0ZUFuZEZpbGwoKSkgOiBlbXB0eSB8fCAoZW1wdHkgPSB0eXBlcy5jZWxsLmNyZWF0ZUFuZEZpbGwoKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGVtcHR5Um93ID0gdHlwZXMucm93LmNyZWF0ZShudWxsLCBGcmFnbWVudDMuZnJvbShjZWxscykpLCByb3dzID0gW107XG4gICAgZm9yIChsZXQgaSA9IG1hcC5oZWlnaHQ7IGkgPCBoZWlnaHQ7IGkrKykgcm93cy5wdXNoKGVtcHR5Um93KTtcbiAgICB0ci5pbnNlcnQodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAoc3RhcnQgKyB0YWJsZS5ub2RlU2l6ZSAtIDIpLCByb3dzKTtcbiAgfVxuICByZXR1cm4gISEoZW1wdHkgfHwgZW1wdHlIZWFkKTtcbn1cbmZ1bmN0aW9uIGlzb2xhdGVIb3Jpem9udGFsKHRyLCBtYXAsIHRhYmxlLCBzdGFydCwgbGVmdCwgcmlnaHQsIHRvcCwgbWFwRnJvbSkge1xuICBpZiAodG9wID09IDAgfHwgdG9wID09IG1hcC5oZWlnaHQpIHJldHVybiBmYWxzZTtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGZvciAobGV0IGNvbCA9IGxlZnQ7IGNvbCA8IHJpZ2h0OyBjb2wrKykge1xuICAgIGNvbnN0IGluZGV4ID0gdG9wICogbWFwLndpZHRoICsgY29sLCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICBpZiAobWFwLm1hcFtpbmRleCAtIG1hcC53aWR0aF0gPT0gcG9zKSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBjb25zdCBjZWxsID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgICBjb25zdCB7IHRvcDogY2VsbFRvcCwgbGVmdDogY2VsbExlZnQgfSA9IG1hcC5maW5kQ2VsbChwb3MpO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyBzdGFydCksIG51bGwsIHtcbiAgICAgICAgLi4uY2VsbC5hdHRycyxcbiAgICAgICAgcm93c3BhbjogdG9wIC0gY2VsbFRvcFxuICAgICAgfSk7XG4gICAgICB0ci5pbnNlcnQoXG4gICAgICAgIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKG1hcC5wb3NpdGlvbkF0KHRvcCwgY2VsbExlZnQsIHRhYmxlKSksXG4gICAgICAgIGNlbGwudHlwZS5jcmVhdGVBbmRGaWxsKHtcbiAgICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICAgIHJvd3NwYW46IGNlbGxUb3AgKyBjZWxsLmF0dHJzLnJvd3NwYW4gLSB0b3BcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBjb2wgKz0gY2VsbC5hdHRycy5jb2xzcGFuIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaXNvbGF0ZVZlcnRpY2FsKHRyLCBtYXAsIHRhYmxlLCBzdGFydCwgdG9wLCBib3R0b20sIGxlZnQsIG1hcEZyb20pIHtcbiAgaWYgKGxlZnQgPT0gMCB8fCBsZWZ0ID09IG1hcC53aWR0aCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgZm9yIChsZXQgcm93ID0gdG9wOyByb3cgPCBib3R0b207IHJvdysrKSB7XG4gICAgY29uc3QgaW5kZXggPSByb3cgKiBtYXAud2lkdGggKyBsZWZ0LCBwb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICBpZiAobWFwLm1hcFtpbmRleCAtIDFdID09IHBvcykge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuICAgICAgY29uc3QgY2VsbExlZnQgPSBtYXAuY29sQ291bnQocG9zKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVBvcyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIHN0YXJ0KTtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgIHVwZGF0ZVBvcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVtb3ZlQ29sU3BhbihcbiAgICAgICAgICBjZWxsLmF0dHJzLFxuICAgICAgICAgIGxlZnQgLSBjZWxsTGVmdCxcbiAgICAgICAgICBjZWxsLmF0dHJzLmNvbHNwYW4gLSAobGVmdCAtIGNlbGxMZWZ0KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdHIuaW5zZXJ0KFxuICAgICAgICB1cGRhdGVQb3MgKyBjZWxsLm5vZGVTaXplLFxuICAgICAgICBjZWxsLnR5cGUuY3JlYXRlQW5kRmlsbChcbiAgICAgICAgICByZW1vdmVDb2xTcGFuKGNlbGwuYXR0cnMsIDAsIGxlZnQgLSBjZWxsTGVmdClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJvdyArPSBjZWxsLmF0dHJzLnJvd3NwYW4gLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpbnNlcnRDZWxscyhzdGF0ZSwgZGlzcGF0Y2gsIHRhYmxlU3RhcnQsIHJlY3QsIGNlbGxzKSB7XG4gIGxldCB0YWJsZSA9IHRhYmxlU3RhcnQgPyBzdGF0ZS5kb2Mubm9kZUF0KHRhYmxlU3RhcnQgLSAxKSA6IHN0YXRlLmRvYztcbiAgaWYgKCF0YWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRhYmxlIGZvdW5kXCIpO1xuICB9XG4gIGxldCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gcmVjdDtcbiAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgY2VsbHMud2lkdGgsIGJvdHRvbSA9IHRvcCArIGNlbGxzLmhlaWdodDtcbiAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgbGV0IG1hcEZyb20gPSAwO1xuICBmdW5jdGlvbiByZWNvbXAoKSB7XG4gICAgdGFibGUgPSB0YWJsZVN0YXJ0ID8gdHIuZG9jLm5vZGVBdCh0YWJsZVN0YXJ0IC0gMSkgOiB0ci5kb2M7XG4gICAgaWYgKCF0YWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGFibGUgZm91bmRcIik7XG4gICAgfVxuICAgIG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgbWFwRnJvbSA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG4gIH1cbiAgaWYgKGdyb3dUYWJsZSh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgcmlnaHQsIGJvdHRvbSwgbWFwRnJvbSkpIHJlY29tcCgpO1xuICBpZiAoaXNvbGF0ZUhvcml6b250YWwodHIsIG1hcCwgdGFibGUsIHRhYmxlU3RhcnQsIGxlZnQsIHJpZ2h0LCB0b3AsIG1hcEZyb20pKVxuICAgIHJlY29tcCgpO1xuICBpZiAoaXNvbGF0ZUhvcml6b250YWwodHIsIG1hcCwgdGFibGUsIHRhYmxlU3RhcnQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIG1hcEZyb20pKVxuICAgIHJlY29tcCgpO1xuICBpZiAoaXNvbGF0ZVZlcnRpY2FsKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCB0b3AsIGJvdHRvbSwgbGVmdCwgbWFwRnJvbSkpXG4gICAgcmVjb21wKCk7XG4gIGlmIChpc29sYXRlVmVydGljYWwodHIsIG1hcCwgdGFibGUsIHRhYmxlU3RhcnQsIHRvcCwgYm90dG9tLCByaWdodCwgbWFwRnJvbSkpXG4gICAgcmVjb21wKCk7XG4gIGZvciAobGV0IHJvdyA9IHRvcDsgcm93IDwgYm90dG9tOyByb3crKykge1xuICAgIGNvbnN0IGZyb20gPSBtYXAucG9zaXRpb25BdChyb3csIGxlZnQsIHRhYmxlKSwgdG8gPSBtYXAucG9zaXRpb25BdChyb3csIHJpZ2h0LCB0YWJsZSk7XG4gICAgdHIucmVwbGFjZShcbiAgICAgIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKGZyb20gKyB0YWJsZVN0YXJ0KSxcbiAgICAgIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHRvICsgdGFibGVTdGFydCksXG4gICAgICBuZXcgU2xpY2UzKGNlbGxzLnJvd3Nbcm93IC0gdG9wXSwgMCwgMClcbiAgICApO1xuICB9XG4gIHJlY29tcCgpO1xuICB0ci5zZXRTZWxlY3Rpb24oXG4gICAgbmV3IENlbGxTZWxlY3Rpb24oXG4gICAgICB0ci5kb2MucmVzb2x2ZSh0YWJsZVN0YXJ0ICsgbWFwLnBvc2l0aW9uQXQodG9wLCBsZWZ0LCB0YWJsZSkpLFxuICAgICAgdHIuZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5wb3NpdGlvbkF0KGJvdHRvbSAtIDEsIHJpZ2h0IC0gMSwgdGFibGUpKVxuICAgIClcbiAgKTtcbiAgZGlzcGF0Y2godHIpO1xufVxuXG4vLyBzcmMvaW5wdXQudHNcbnZhciBoYW5kbGVLZXlEb3duID0ga2V5ZG93bkhhbmRsZXIoe1xuICBBcnJvd0xlZnQ6IGFycm93KFwiaG9yaXpcIiwgLTEpLFxuICBBcnJvd1JpZ2h0OiBhcnJvdyhcImhvcml6XCIsIDEpLFxuICBBcnJvd1VwOiBhcnJvdyhcInZlcnRcIiwgLTEpLFxuICBBcnJvd0Rvd246IGFycm93KFwidmVydFwiLCAxKSxcbiAgXCJTaGlmdC1BcnJvd0xlZnRcIjogc2hpZnRBcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgXCJTaGlmdC1BcnJvd1JpZ2h0XCI6IHNoaWZ0QXJyb3coXCJob3JpelwiLCAxKSxcbiAgXCJTaGlmdC1BcnJvd1VwXCI6IHNoaWZ0QXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgXCJTaGlmdC1BcnJvd0Rvd25cIjogc2hpZnRBcnJvdyhcInZlcnRcIiwgMSksXG4gIEJhY2tzcGFjZTogZGVsZXRlQ2VsbFNlbGVjdGlvbixcbiAgXCJNb2QtQmFja3NwYWNlXCI6IGRlbGV0ZUNlbGxTZWxlY3Rpb24sXG4gIERlbGV0ZTogZGVsZXRlQ2VsbFNlbGVjdGlvbixcbiAgXCJNb2QtRGVsZXRlXCI6IGRlbGV0ZUNlbGxTZWxlY3Rpb25cbn0pO1xuZnVuY3Rpb24gbWF5YmVTZXRTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoLCBzZWxlY3Rpb24pIHtcbiAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgaWYgKCF2aWV3KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbWF5YmVTZXRTZWxlY3Rpb24oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgU2VsZWN0aW9uMi5uZWFyKHNlbC4kaGVhZENlbGwsIGRpcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChheGlzICE9IFwiaG9yaXpcIiAmJiAhc2VsLmVtcHR5KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZW5kID0gYXRFbmRPZkNlbGwodmlldywgYXhpcywgZGlyKTtcbiAgICBpZiAoZW5kID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXhpcyA9PSBcImhvcml6XCIpIHtcbiAgICAgIHJldHVybiBtYXliZVNldFNlbGVjdGlvbihcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBTZWxlY3Rpb24yLm5lYXIoc3RhdGUuZG9jLnJlc29sdmUoc2VsLmhlYWQgKyBkaXIpLCBkaXIpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCAkY2VsbCA9IHN0YXRlLmRvYy5yZXNvbHZlKGVuZCk7XG4gICAgICBjb25zdCAkbmV4dCA9IG5leHRDZWxsKCRjZWxsLCBheGlzLCBkaXIpO1xuICAgICAgbGV0IG5ld1NlbDtcbiAgICAgIGlmICgkbmV4dCkgbmV3U2VsID0gU2VsZWN0aW9uMi5uZWFyKCRuZXh0LCAxKTtcbiAgICAgIGVsc2UgaWYgKGRpciA8IDApXG4gICAgICAgIG5ld1NlbCA9IFNlbGVjdGlvbjIubmVhcihzdGF0ZS5kb2MucmVzb2x2ZSgkY2VsbC5iZWZvcmUoLTEpKSwgLTEpO1xuICAgICAgZWxzZSBuZXdTZWwgPSBTZWxlY3Rpb24yLm5lYXIoc3RhdGUuZG9jLnJlc29sdmUoJGNlbGwuYWZ0ZXIoLTEpKSwgMSk7XG4gICAgICByZXR1cm4gbWF5YmVTZXRTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoLCBuZXdTZWwpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaWZ0QXJyb3coYXhpcywgZGlyKSB7XG4gIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgaWYgKCF2aWV3KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBjZWxsU2VsO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB7XG4gICAgICBjZWxsU2VsID0gc2VsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbmQgPSBhdEVuZE9mQ2VsbCh2aWV3LCBheGlzLCBkaXIpO1xuICAgICAgaWYgKGVuZCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBjZWxsU2VsID0gbmV3IENlbGxTZWxlY3Rpb24oc3RhdGUuZG9jLnJlc29sdmUoZW5kKSk7XG4gICAgfVxuICAgIGNvbnN0ICRoZWFkID0gbmV4dENlbGwoY2VsbFNlbC4kaGVhZENlbGwsIGF4aXMsIGRpcik7XG4gICAgaWYgKCEkaGVhZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBtYXliZVNldFNlbGVjdGlvbihcbiAgICAgIHN0YXRlLFxuICAgICAgZGlzcGF0Y2gsXG4gICAgICBuZXcgQ2VsbFNlbGVjdGlvbihjZWxsU2VsLiRhbmNob3JDZWxsLCAkaGVhZClcbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlVHJpcGxlQ2xpY2sodmlldywgcG9zKSB7XG4gIGNvbnN0IGRvYyA9IHZpZXcuc3RhdGUuZG9jLCAkY2VsbCA9IGNlbGxBcm91bmQoZG9jLnJlc29sdmUocG9zKSk7XG4gIGlmICghJGNlbGwpIHJldHVybiBmYWxzZTtcbiAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQ2VsbFNlbGVjdGlvbigkY2VsbCkpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBoYW5kbGVQYXN0ZSh2aWV3LCBfLCBzbGljZSkge1xuICBpZiAoIWlzSW5UYWJsZSh2aWV3LnN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICBsZXQgY2VsbHMgPSBwYXN0ZWRDZWxscyhzbGljZSk7XG4gIGNvbnN0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuICAgIGlmICghY2VsbHMpXG4gICAgICBjZWxscyA9IHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgcm93czogW1xuICAgICAgICAgIEZyYWdtZW50NC5mcm9tKFxuICAgICAgICAgICAgZml0U2xpY2UodGFibGVOb2RlVHlwZXModmlldy5zdGF0ZS5zY2hlbWEpLmNlbGwsIHNsaWNlKVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICBjb25zdCB0YWJsZSA9IHNlbC4kYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBzdGFydCA9IHNlbC4kYW5jaG9yQ2VsbC5zdGFydCgtMSk7XG4gICAgY29uc3QgcmVjdCA9IFRhYmxlTWFwLmdldCh0YWJsZSkucmVjdEJldHdlZW4oXG4gICAgICBzZWwuJGFuY2hvckNlbGwucG9zIC0gc3RhcnQsXG4gICAgICBzZWwuJGhlYWRDZWxsLnBvcyAtIHN0YXJ0XG4gICAgKTtcbiAgICBjZWxscyA9IGNsaXBDZWxscyhjZWxscywgcmVjdC5yaWdodCAtIHJlY3QubGVmdCwgcmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG4gICAgaW5zZXJ0Q2VsbHModmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgc3RhcnQsIHJlY3QsIGNlbGxzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjZWxscykge1xuICAgIGNvbnN0ICRjZWxsID0gc2VsZWN0aW9uQ2VsbCh2aWV3LnN0YXRlKTtcbiAgICBjb25zdCBzdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcbiAgICBpbnNlcnRDZWxscyhcbiAgICAgIHZpZXcuc3RhdGUsXG4gICAgICB2aWV3LmRpc3BhdGNoLFxuICAgICAgc3RhcnQsXG4gICAgICBUYWJsZU1hcC5nZXQoJGNlbGwubm9kZSgtMSkpLmZpbmRDZWxsKCRjZWxsLnBvcyAtIHN0YXJ0KSxcbiAgICAgIGNlbGxzXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bih2aWV3LCBzdGFydEV2ZW50KSB7XG4gIHZhciBfYTtcbiAgaWYgKHN0YXJ0RXZlbnQuY3RybEtleSB8fCBzdGFydEV2ZW50Lm1ldGFLZXkpIHJldHVybjtcbiAgY29uc3Qgc3RhcnRET01DZWxsID0gZG9tSW5DZWxsKHZpZXcsIHN0YXJ0RXZlbnQudGFyZ2V0KTtcbiAgbGV0ICRhbmNob3I7XG4gIGlmIChzdGFydEV2ZW50LnNoaWZ0S2V5ICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuICAgIHNldENlbGxTZWxlY3Rpb24odmlldy5zdGF0ZS5zZWxlY3Rpb24uJGFuY2hvckNlbGwsIHN0YXJ0RXZlbnQpO1xuICAgIHN0YXJ0RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSBlbHNlIGlmIChzdGFydEV2ZW50LnNoaWZ0S2V5ICYmIHN0YXJ0RE9NQ2VsbCAmJiAoJGFuY2hvciA9IGNlbGxBcm91bmQodmlldy5zdGF0ZS5zZWxlY3Rpb24uJGFuY2hvcikpICE9IG51bGwgJiYgKChfYSA9IGNlbGxVbmRlck1vdXNlKHZpZXcsIHN0YXJ0RXZlbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EucG9zKSAhPSAkYW5jaG9yLnBvcykge1xuICAgIHNldENlbGxTZWxlY3Rpb24oJGFuY2hvciwgc3RhcnRFdmVudCk7XG4gICAgc3RhcnRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2UgaWYgKCFzdGFydERPTUNlbGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZnVuY3Rpb24gc2V0Q2VsbFNlbGVjdGlvbigkYW5jaG9yMiwgZXZlbnQpIHtcbiAgICBsZXQgJGhlYWQgPSBjZWxsVW5kZXJNb3VzZSh2aWV3LCBldmVudCk7XG4gICAgY29uc3Qgc3RhcnRpbmcgPSB0YWJsZUVkaXRpbmdLZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSkgPT0gbnVsbDtcbiAgICBpZiAoISRoZWFkIHx8ICFpblNhbWVUYWJsZSgkYW5jaG9yMiwgJGhlYWQpKSB7XG4gICAgICBpZiAoc3RhcnRpbmcpICRoZWFkID0gJGFuY2hvcjI7XG4gICAgICBlbHNlIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbmV3IENlbGxTZWxlY3Rpb24oJGFuY2hvcjIsICRoZWFkKTtcbiAgICBpZiAoc3RhcnRpbmcgfHwgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIGlmIChzdGFydGluZykgdHIuc2V0TWV0YSh0YWJsZUVkaXRpbmdLZXksICRhbmNob3IyLnBvcyk7XG4gICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgc3RvcCk7XG4gICAgdmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgc3RvcCk7XG4gICAgdmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgaWYgKHRhYmxlRWRpdGluZ0tleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKSAhPSBudWxsKVxuICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldE1ldGEodGFibGVFZGl0aW5nS2V5LCAtMSkpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmUoX2V2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgY29uc3QgYW5jaG9yID0gdGFibGVFZGl0aW5nS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICAgIGxldCAkYW5jaG9yMjtcbiAgICBpZiAoYW5jaG9yICE9IG51bGwpIHtcbiAgICAgICRhbmNob3IyID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShhbmNob3IpO1xuICAgIH0gZWxzZSBpZiAoZG9tSW5DZWxsKHZpZXcsIGV2ZW50LnRhcmdldCkgIT0gc3RhcnRET01DZWxsKSB7XG4gICAgICAkYW5jaG9yMiA9IGNlbGxVbmRlck1vdXNlKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgaWYgKCEkYW5jaG9yMikgcmV0dXJuIHN0b3AoKTtcbiAgICB9XG4gICAgaWYgKCRhbmNob3IyKSBzZXRDZWxsU2VsZWN0aW9uKCRhbmNob3IyLCBldmVudCk7XG4gIH1cbiAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHN0b3ApO1xuICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBzdG9wKTtcbiAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG59XG5mdW5jdGlvbiBhdEVuZE9mQ2VsbCh2aWV3LCBheGlzLCBkaXIpIHtcbiAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uMykpIHJldHVybiBudWxsO1xuICBjb25zdCB7ICRoZWFkIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgZm9yIChsZXQgZCA9ICRoZWFkLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICBjb25zdCBwYXJlbnQgPSAkaGVhZC5ub2RlKGQpLCBpbmRleCA9IGRpciA8IDAgPyAkaGVhZC5pbmRleChkKSA6ICRoZWFkLmluZGV4QWZ0ZXIoZCk7XG4gICAgaWYgKGluZGV4ICE9IChkaXIgPCAwID8gMCA6IHBhcmVudC5jaGlsZENvdW50KSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwiY2VsbFwiIHx8IHBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwiaGVhZGVyX2NlbGxcIikge1xuICAgICAgY29uc3QgY2VsbFBvcyA9ICRoZWFkLmJlZm9yZShkKTtcbiAgICAgIGNvbnN0IGRpclN0ciA9IGF4aXMgPT0gXCJ2ZXJ0XCIgPyBkaXIgPiAwID8gXCJkb3duXCIgOiBcInVwXCIgOiBkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgICByZXR1cm4gdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpID8gY2VsbFBvcyA6IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZG9tSW5DZWxsKHZpZXcsIGRvbSkge1xuICBmb3IgKDsgZG9tICYmIGRvbSAhPSB2aWV3LmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiVERcIiB8fCBkb20ubm9kZU5hbWUgPT0gXCJUSFwiKSB7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNlbGxVbmRlck1vdXNlKHZpZXcsIGV2ZW50KSB7XG4gIGNvbnN0IG1vdXNlUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7XG4gICAgbGVmdDogZXZlbnQuY2xpZW50WCxcbiAgICB0b3A6IGV2ZW50LmNsaWVudFlcbiAgfSk7XG4gIGlmICghbW91c2VQb3MpIHJldHVybiBudWxsO1xuICByZXR1cm4gbW91c2VQb3MgPyBjZWxsQXJvdW5kKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUobW91c2VQb3MucG9zKSkgOiBudWxsO1xufVxuXG4vLyBzcmMvY29sdW1ucmVzaXppbmcudHNcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IGFzIFBsdWdpbktleTMgfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbmltcG9ydCB7XG4gIERlY29yYXRpb24gYXMgRGVjb3JhdGlvbjIsXG4gIERlY29yYXRpb25TZXQgYXMgRGVjb3JhdGlvblNldDJcbn0gZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjtcblxuLy8gc3JjL3RhYmxldmlldy50c1xudmFyIFRhYmxlVmlldyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgZGVmYXVsdENlbGxNaW5XaWR0aCkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5kZWZhdWx0Q2VsbE1pbldpZHRoID0gZGVmYXVsdENlbGxNaW5XaWR0aDtcbiAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJ0YWJsZVdyYXBwZXJcIjtcbiAgICB0aGlzLnRhYmxlID0gdGhpcy5kb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpKTtcbiAgICB0aGlzLnRhYmxlLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgXCItLWRlZmF1bHQtY2VsbC1taW4td2lkdGhcIixcbiAgICAgIGAke2RlZmF1bHRDZWxsTWluV2lkdGh9cHhgXG4gICAgKTtcbiAgICB0aGlzLmNvbGdyb3VwID0gdGhpcy50YWJsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29sZ3JvdXBcIikpO1xuICAgIHVwZGF0ZUNvbHVtbnNPblJlc2l6ZShub2RlLCB0aGlzLmNvbGdyb3VwLCB0aGlzLnRhYmxlLCBkZWZhdWx0Q2VsbE1pbldpZHRoKTtcbiAgICB0aGlzLmNvbnRlbnRET00gPSB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiKSk7XG4gIH1cbiAgdXBkYXRlKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlICE9IHRoaXMubm9kZS50eXBlKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB1cGRhdGVDb2x1bW5zT25SZXNpemUoXG4gICAgICBub2RlLFxuICAgICAgdGhpcy5jb2xncm91cCxcbiAgICAgIHRoaXMudGFibGUsXG4gICAgICB0aGlzLmRlZmF1bHRDZWxsTWluV2lkdGhcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlnbm9yZU11dGF0aW9uKHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIiAmJiAocmVjb3JkLnRhcmdldCA9PSB0aGlzLnRhYmxlIHx8IHRoaXMuY29sZ3JvdXAuY29udGFpbnMocmVjb3JkLnRhcmdldCkpO1xuICB9XG59O1xuZnVuY3Rpb24gdXBkYXRlQ29sdW1uc09uUmVzaXplKG5vZGUsIGNvbGdyb3VwLCB0YWJsZSwgZGVmYXVsdENlbGxNaW5XaWR0aCwgb3ZlcnJpZGVDb2wsIG92ZXJyaWRlVmFsdWUpIHtcbiAgdmFyIF9hO1xuICBsZXQgdG90YWxXaWR0aCA9IDA7XG4gIGxldCBmaXhlZFdpZHRoID0gdHJ1ZTtcbiAgbGV0IG5leHRET00gPSBjb2xncm91cC5maXJzdENoaWxkO1xuICBjb25zdCByb3cgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIGlmICghcm93KSByZXR1cm47XG4gIGZvciAobGV0IGkgPSAwLCBjb2wgPSAwOyBpIDwgcm93LmNoaWxkQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IHsgY29sc3BhbiwgY29sd2lkdGggfSA9IHJvdy5jaGlsZChpKS5hdHRycztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHNwYW47IGorKywgY29sKyspIHtcbiAgICAgIGNvbnN0IGhhc1dpZHRoID0gb3ZlcnJpZGVDb2wgPT0gY29sID8gb3ZlcnJpZGVWYWx1ZSA6IGNvbHdpZHRoICYmIGNvbHdpZHRoW2pdO1xuICAgICAgY29uc3QgY3NzV2lkdGggPSBoYXNXaWR0aCA/IGhhc1dpZHRoICsgXCJweFwiIDogXCJcIjtcbiAgICAgIHRvdGFsV2lkdGggKz0gaGFzV2lkdGggfHwgZGVmYXVsdENlbGxNaW5XaWR0aDtcbiAgICAgIGlmICghaGFzV2lkdGgpIGZpeGVkV2lkdGggPSBmYWxzZTtcbiAgICAgIGlmICghbmV4dERPTSkge1xuICAgICAgICBjb25zdCBjb2wyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNvbFwiKTtcbiAgICAgICAgY29sMi5zdHlsZS53aWR0aCA9IGNzc1dpZHRoO1xuICAgICAgICBjb2xncm91cC5hcHBlbmRDaGlsZChjb2wyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXh0RE9NLnN0eWxlLndpZHRoICE9IGNzc1dpZHRoKSB7XG4gICAgICAgICAgbmV4dERPTS5zdHlsZS53aWR0aCA9IGNzc1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIG5leHRET00gPSBuZXh0RE9NLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB3aGlsZSAobmV4dERPTSkge1xuICAgIGNvbnN0IGFmdGVyID0gbmV4dERPTS5uZXh0U2libGluZztcbiAgICAoX2EgPSBuZXh0RE9NLnBhcmVudE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChuZXh0RE9NKTtcbiAgICBuZXh0RE9NID0gYWZ0ZXI7XG4gIH1cbiAgaWYgKGZpeGVkV2lkdGgpIHtcbiAgICB0YWJsZS5zdHlsZS53aWR0aCA9IHRvdGFsV2lkdGggKyBcInB4XCI7XG4gICAgdGFibGUuc3R5bGUubWluV2lkdGggPSBcIlwiO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICB0YWJsZS5zdHlsZS5taW5XaWR0aCA9IHRvdGFsV2lkdGggKyBcInB4XCI7XG4gIH1cbn1cblxuLy8gc3JjL2NvbHVtbnJlc2l6aW5nLnRzXG52YXIgY29sdW1uUmVzaXppbmdQbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5MyhcbiAgXCJ0YWJsZUNvbHVtblJlc2l6aW5nXCJcbik7XG5mdW5jdGlvbiBjb2x1bW5SZXNpemluZyh7XG4gIGhhbmRsZVdpZHRoID0gNSxcbiAgY2VsbE1pbldpZHRoID0gMjUsXG4gIGRlZmF1bHRDZWxsTWluV2lkdGggPSAxMDAsXG4gIFZpZXcgPSBUYWJsZVZpZXcsXG4gIGxhc3RDb2x1bW5SZXNpemFibGUgPSB0cnVlXG59ID0ge30pIHtcbiAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAga2V5OiBjb2x1bW5SZXNpemluZ1BsdWdpbktleSxcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdChfLCBzdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBub2RlVmlld3MgPSAoX2IgPSAoX2EgPSBwbHVnaW4uc3BlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX2Iubm9kZVZpZXdzO1xuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZU5vZGVUeXBlcyhzdGF0ZS5zY2hlbWEpLnRhYmxlLm5hbWU7XG4gICAgICAgIGlmIChWaWV3ICYmIG5vZGVWaWV3cykge1xuICAgICAgICAgIG5vZGVWaWV3c1t0YWJsZU5hbWVdID0gKG5vZGUsIHZpZXcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlldyhub2RlLCBkZWZhdWx0Q2VsbE1pbldpZHRoLCB2aWV3KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplU3RhdGUoLTEsIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBhcHBseSh0ciwgcHJldikge1xuICAgICAgICByZXR1cm4gcHJldi5hcHBseSh0cik7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgYXR0cmlidXRlczogKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICByZXR1cm4gcGx1Z2luU3RhdGUgJiYgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlID4gLTEgPyB7IGNsYXNzOiBcInJlc2l6ZS1jdXJzb3JcIiB9IDoge307XG4gICAgICB9LFxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIG1vdXNlbW92ZTogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50LCBoYW5kbGVXaWR0aCwgbGFzdENvbHVtblJlc2l6YWJsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlbGVhdmU6ICh2aWV3KSA9PiB7XG4gICAgICAgICAgaGFuZGxlTW91c2VMZWF2ZSh2aWV3KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vkb3duOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICBoYW5kbGVNb3VzZURvd24yKHZpZXcsIGV2ZW50LCBjZWxsTWluV2lkdGgsIGRlZmF1bHRDZWxsTWluV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGlvbnM6IChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgaWYgKHBsdWdpblN0YXRlICYmIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZURlY29yYXRpb25zKHN0YXRlLCBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm9kZVZpZXdzOiB7fVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwbHVnaW47XG59XG52YXIgUmVzaXplU3RhdGUgPSBjbGFzcyBfUmVzaXplU3RhdGUge1xuICBjb25zdHJ1Y3RvcihhY3RpdmVIYW5kbGUsIGRyYWdnaW5nKSB7XG4gICAgdGhpcy5hY3RpdmVIYW5kbGUgPSBhY3RpdmVIYW5kbGU7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICB9XG4gIGFwcGx5KHRyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRyLmdldE1ldGEoY29sdW1uUmVzaXppbmdQbHVnaW5LZXkpO1xuICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uLnNldEhhbmRsZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG5ldyBfUmVzaXplU3RhdGUoYWN0aW9uLnNldEhhbmRsZSwgZmFsc2UpO1xuICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uLnNldERyYWdnaW5nICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gbmV3IF9SZXNpemVTdGF0ZShzdGF0ZS5hY3RpdmVIYW5kbGUsIGFjdGlvbi5zZXREcmFnZ2luZyk7XG4gICAgaWYgKHN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xICYmIHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgIGxldCBoYW5kbGUgPSB0ci5tYXBwaW5nLm1hcChzdGF0ZS5hY3RpdmVIYW5kbGUsIC0xKTtcbiAgICAgIGlmICghcG9pbnRzQXRDZWxsKHRyLmRvYy5yZXNvbHZlKGhhbmRsZSkpKSB7XG4gICAgICAgIGhhbmRsZSA9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBfUmVzaXplU3RhdGUoaGFuZGxlLCBzdGF0ZS5kcmFnZ2luZyk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCwgaGFuZGxlV2lkdGgsIGxhc3RDb2x1bW5SZXNpemFibGUpIHtcbiAgaWYgKCF2aWV3LmVkaXRhYmxlKSByZXR1cm47XG4gIGNvbnN0IHBsdWdpblN0YXRlID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gIGlmICghcGx1Z2luU3RhdGUpIHJldHVybjtcbiAgaWYgKCFwbHVnaW5TdGF0ZS5kcmFnZ2luZykge1xuICAgIGNvbnN0IHRhcmdldCA9IGRvbUNlbGxBcm91bmQoZXZlbnQudGFyZ2V0KTtcbiAgICBsZXQgY2VsbCA9IC0xO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmIChldmVudC5jbGllbnRYIC0gbGVmdCA8PSBoYW5kbGVXaWR0aClcbiAgICAgICAgY2VsbCA9IGVkZ2VDZWxsKHZpZXcsIGV2ZW50LCBcImxlZnRcIiwgaGFuZGxlV2lkdGgpO1xuICAgICAgZWxzZSBpZiAocmlnaHQgLSBldmVudC5jbGllbnRYIDw9IGhhbmRsZVdpZHRoKVxuICAgICAgICBjZWxsID0gZWRnZUNlbGwodmlldywgZXZlbnQsIFwicmlnaHRcIiwgaGFuZGxlV2lkdGgpO1xuICAgIH1cbiAgICBpZiAoY2VsbCAhPSBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUpIHtcbiAgICAgIGlmICghbGFzdENvbHVtblJlc2l6YWJsZSAmJiBjZWxsICE9PSAtMSkge1xuICAgICAgICBjb25zdCAkY2VsbCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSk7XG4gICAgICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgICAgIGNvbnN0IHRhYmxlU3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gICAgICAgIGNvbnN0IGNvbCA9IG1hcC5jb2xDb3VudCgkY2VsbC5wb3MgLSB0YWJsZVN0YXJ0KSArICRjZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuIC0gMTtcbiAgICAgICAgaWYgKGNvbCA9PSBtYXAud2lkdGggLSAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVIYW5kbGUodmlldywgY2VsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVNb3VzZUxlYXZlKHZpZXcpIHtcbiAgaWYgKCF2aWV3LmVkaXRhYmxlKSByZXR1cm47XG4gIGNvbnN0IHBsdWdpblN0YXRlID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gIGlmIChwbHVnaW5TdGF0ZSAmJiBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUgPiAtMSAmJiAhcGx1Z2luU3RhdGUuZHJhZ2dpbmcpXG4gICAgdXBkYXRlSGFuZGxlKHZpZXcsIC0xKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bjIodmlldywgZXZlbnQsIGNlbGxNaW5XaWR0aCwgZGVmYXVsdENlbGxNaW5XaWR0aCkge1xuICB2YXIgX2E7XG4gIGlmICghdmlldy5lZGl0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB3aW4gPSAoX2EgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAhPSBudWxsID8gX2EgOiB3aW5kb3c7XG4gIGNvbnN0IHBsdWdpblN0YXRlID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gIGlmICghcGx1Z2luU3RhdGUgfHwgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlID09IC0xIHx8IHBsdWdpblN0YXRlLmRyYWdnaW5nKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgY2VsbCA9IHZpZXcuc3RhdGUuZG9jLm5vZGVBdChwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUpO1xuICBjb25zdCB3aWR0aCA9IGN1cnJlbnRDb2xXaWR0aCh2aWV3LCBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUsIGNlbGwuYXR0cnMpO1xuICB2aWV3LmRpc3BhdGNoKFxuICAgIHZpZXcuc3RhdGUudHIuc2V0TWV0YShjb2x1bW5SZXNpemluZ1BsdWdpbktleSwge1xuICAgICAgc2V0RHJhZ2dpbmc6IHsgc3RhcnRYOiBldmVudC5jbGllbnRYLCBzdGFydFdpZHRoOiB3aWR0aCB9XG4gICAgfSlcbiAgKTtcbiAgZnVuY3Rpb24gZmluaXNoKGV2ZW50Mikge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmaW5pc2gpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgIGNvbnN0IHBsdWdpblN0YXRlMiA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICAgIGlmIChwbHVnaW5TdGF0ZTIgPT0gbnVsbCA/IHZvaWQgMCA6IHBsdWdpblN0YXRlMi5kcmFnZ2luZykge1xuICAgICAgdXBkYXRlQ29sdW1uV2lkdGgoXG4gICAgICAgIHZpZXcsXG4gICAgICAgIHBsdWdpblN0YXRlMi5hY3RpdmVIYW5kbGUsXG4gICAgICAgIGRyYWdnZWRXaWR0aChwbHVnaW5TdGF0ZTIuZHJhZ2dpbmcsIGV2ZW50MiwgY2VsbE1pbldpZHRoKVxuICAgICAgKTtcbiAgICAgIHZpZXcuZGlzcGF0Y2goXG4gICAgICAgIHZpZXcuc3RhdGUudHIuc2V0TWV0YShjb2x1bW5SZXNpemluZ1BsdWdpbktleSwgeyBzZXREcmFnZ2luZzogbnVsbCB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbW92ZShldmVudDIpIHtcbiAgICBpZiAoIWV2ZW50Mi53aGljaCkgcmV0dXJuIGZpbmlzaChldmVudDIpO1xuICAgIGNvbnN0IHBsdWdpblN0YXRlMiA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICAgIGlmICghcGx1Z2luU3RhdGUyKSByZXR1cm47XG4gICAgaWYgKHBsdWdpblN0YXRlMi5kcmFnZ2luZykge1xuICAgICAgY29uc3QgZHJhZ2dlZCA9IGRyYWdnZWRXaWR0aChwbHVnaW5TdGF0ZTIuZHJhZ2dpbmcsIGV2ZW50MiwgY2VsbE1pbldpZHRoKTtcbiAgICAgIGRpc3BsYXlDb2x1bW5XaWR0aChcbiAgICAgICAgdmlldyxcbiAgICAgICAgcGx1Z2luU3RhdGUyLmFjdGl2ZUhhbmRsZSxcbiAgICAgICAgZHJhZ2dlZCxcbiAgICAgICAgZGVmYXVsdENlbGxNaW5XaWR0aFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZGlzcGxheUNvbHVtbldpZHRoKFxuICAgIHZpZXcsXG4gICAgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlLFxuICAgIHdpZHRoLFxuICAgIGRlZmF1bHRDZWxsTWluV2lkdGhcbiAgKTtcbiAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZpbmlzaCk7XG4gIHdpbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGN1cnJlbnRDb2xXaWR0aCh2aWV3LCBjZWxsUG9zLCB7IGNvbHNwYW4sIGNvbHdpZHRoIH0pIHtcbiAgY29uc3Qgd2lkdGggPSBjb2x3aWR0aCAmJiBjb2x3aWR0aFtjb2x3aWR0aC5sZW5ndGggLSAxXTtcbiAgaWYgKHdpZHRoKSByZXR1cm4gd2lkdGg7XG4gIGNvbnN0IGRvbSA9IHZpZXcuZG9tQXRQb3MoY2VsbFBvcyk7XG4gIGNvbnN0IG5vZGUgPSBkb20ubm9kZS5jaGlsZE5vZGVzW2RvbS5vZmZzZXRdO1xuICBsZXQgZG9tV2lkdGggPSBub2RlLm9mZnNldFdpZHRoLCBwYXJ0cyA9IGNvbHNwYW47XG4gIGlmIChjb2x3aWR0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sc3BhbjsgaSsrKVxuICAgICAgaWYgKGNvbHdpZHRoW2ldKSB7XG4gICAgICAgIGRvbVdpZHRoIC09IGNvbHdpZHRoW2ldO1xuICAgICAgICBwYXJ0cy0tO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBkb21XaWR0aCAvIHBhcnRzO1xufVxuZnVuY3Rpb24gZG9tQ2VsbEFyb3VuZCh0YXJnZXQpIHtcbiAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUgIT0gXCJURFwiICYmIHRhcmdldC5ub2RlTmFtZSAhPSBcIlRIXCIpXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNsYXNzTGlzdCAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiUHJvc2VNaXJyb3JcIikgPyBudWxsIDogdGFyZ2V0LnBhcmVudE5vZGU7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBlZGdlQ2VsbCh2aWV3LCBldmVudCwgc2lkZSwgaGFuZGxlV2lkdGgpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2lkZSA9PSBcInJpZ2h0XCIgPyAtaGFuZGxlV2lkdGggOiBoYW5kbGVXaWR0aDtcbiAgY29uc3QgZm91bmQgPSB2aWV3LnBvc0F0Q29vcmRzKHtcbiAgICBsZWZ0OiBldmVudC5jbGllbnRYICsgb2Zmc2V0LFxuICAgIHRvcDogZXZlbnQuY2xpZW50WVxuICB9KTtcbiAgaWYgKCFmb3VuZCkgcmV0dXJuIC0xO1xuICBjb25zdCB7IHBvcyB9ID0gZm91bmQ7XG4gIGNvbnN0ICRjZWxsID0gY2VsbEFyb3VuZCh2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcykpO1xuICBpZiAoISRjZWxsKSByZXR1cm4gLTE7XG4gIGlmIChzaWRlID09IFwicmlnaHRcIikgcmV0dXJuICRjZWxsLnBvcztcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KCRjZWxsLm5vZGUoLTEpKSwgc3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gIGNvbnN0IGluZGV4ID0gbWFwLm1hcC5pbmRleE9mKCRjZWxsLnBvcyAtIHN0YXJ0KTtcbiAgcmV0dXJuIGluZGV4ICUgbWFwLndpZHRoID09IDAgPyAtMSA6IHN0YXJ0ICsgbWFwLm1hcFtpbmRleCAtIDFdO1xufVxuZnVuY3Rpb24gZHJhZ2dlZFdpZHRoKGRyYWdnaW5nLCBldmVudCwgcmVzaXplTWluV2lkdGgpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gZXZlbnQuY2xpZW50WCAtIGRyYWdnaW5nLnN0YXJ0WDtcbiAgcmV0dXJuIE1hdGgubWF4KHJlc2l6ZU1pbldpZHRoLCBkcmFnZ2luZy5zdGFydFdpZHRoICsgb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhhbmRsZSh2aWV3LCB2YWx1ZSkge1xuICB2aWV3LmRpc3BhdGNoKFxuICAgIHZpZXcuc3RhdGUudHIuc2V0TWV0YShjb2x1bW5SZXNpemluZ1BsdWdpbktleSwgeyBzZXRIYW5kbGU6IHZhbHVlIH0pXG4gICk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb2x1bW5XaWR0aCh2aWV3LCBjZWxsLCB3aWR0aCkge1xuICBjb25zdCAkY2VsbCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG4gIGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSksIG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSksIHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuICBjb25zdCBjb2wgPSBtYXAuY29sQ291bnQoJGNlbGwucG9zIC0gc3RhcnQpICsgJGNlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW4gLSAxO1xuICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7IHJvdysrKSB7XG4gICAgY29uc3QgbWFwSW5kZXggPSByb3cgKiBtYXAud2lkdGggKyBjb2w7XG4gICAgaWYgKHJvdyAmJiBtYXAubWFwW21hcEluZGV4XSA9PSBtYXAubWFwW21hcEluZGV4IC0gbWFwLndpZHRoXSkgY29udGludWU7XG4gICAgY29uc3QgcG9zID0gbWFwLm1hcFttYXBJbmRleF07XG4gICAgY29uc3QgYXR0cnMgPSB0YWJsZS5ub2RlQXQocG9zKS5hdHRycztcbiAgICBjb25zdCBpbmRleCA9IGF0dHJzLmNvbHNwYW4gPT0gMSA/IDAgOiBjb2wgLSBtYXAuY29sQ291bnQocG9zKTtcbiAgICBpZiAoYXR0cnMuY29sd2lkdGggJiYgYXR0cnMuY29sd2lkdGhbaW5kZXhdID09IHdpZHRoKSBjb250aW51ZTtcbiAgICBjb25zdCBjb2x3aWR0aCA9IGF0dHJzLmNvbHdpZHRoID8gYXR0cnMuY29sd2lkdGguc2xpY2UoKSA6IHplcm9lcyhhdHRycy5jb2xzcGFuKTtcbiAgICBjb2x3aWR0aFtpbmRleF0gPSB3aWR0aDtcbiAgICB0ci5zZXROb2RlTWFya3VwKHN0YXJ0ICsgcG9zLCBudWxsLCB7IC4uLmF0dHJzLCBjb2x3aWR0aCB9KTtcbiAgfVxuICBpZiAodHIuZG9jQ2hhbmdlZCkgdmlldy5kaXNwYXRjaCh0cik7XG59XG5mdW5jdGlvbiBkaXNwbGF5Q29sdW1uV2lkdGgodmlldywgY2VsbCwgd2lkdGgsIGRlZmF1bHRDZWxsTWluV2lkdGgpIHtcbiAgY29uc3QgJGNlbGwgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuICBjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpLCBzdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcbiAgY29uc3QgY29sID0gVGFibGVNYXAuZ2V0KHRhYmxlKS5jb2xDb3VudCgkY2VsbC5wb3MgLSBzdGFydCkgKyAkY2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3BhbiAtIDE7XG4gIGxldCBkb20gPSB2aWV3LmRvbUF0UG9zKCRjZWxsLnN0YXJ0KC0xKSkubm9kZTtcbiAgd2hpbGUgKGRvbSAmJiBkb20ubm9kZU5hbWUgIT0gXCJUQUJMRVwiKSB7XG4gICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gIH1cbiAgaWYgKCFkb20pIHJldHVybjtcbiAgdXBkYXRlQ29sdW1uc09uUmVzaXplKFxuICAgIHRhYmxlLFxuICAgIGRvbS5maXJzdENoaWxkLFxuICAgIGRvbSxcbiAgICBkZWZhdWx0Q2VsbE1pbldpZHRoLFxuICAgIGNvbCxcbiAgICB3aWR0aFxuICApO1xufVxuZnVuY3Rpb24gemVyb2VzKG4pIHtcbiAgcmV0dXJuIEFycmF5KG4pLmZpbGwoMCk7XG59XG5mdW5jdGlvbiBoYW5kbGVEZWNvcmF0aW9ucyhzdGF0ZSwgY2VsbCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGRlY29yYXRpb25zID0gW107XG4gIGNvbnN0ICRjZWxsID0gc3RhdGUuZG9jLnJlc29sdmUoY2VsbCk7XG4gIGNvbnN0IHRhYmxlID0gJGNlbGwubm9kZSgtMSk7XG4gIGlmICghdGFibGUpIHtcbiAgICByZXR1cm4gRGVjb3JhdGlvblNldDIuZW1wdHk7XG4gIH1cbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgY29uc3Qgc3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gIGNvbnN0IGNvbCA9IG1hcC5jb2xDb3VudCgkY2VsbC5wb3MgLSBzdGFydCkgKyAkY2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3BhbiAtIDE7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7IHJvdysrKSB7XG4gICAgY29uc3QgaW5kZXggPSBjb2wgKyByb3cgKiBtYXAud2lkdGg7XG4gICAgaWYgKChjb2wgPT0gbWFwLndpZHRoIC0gMSB8fCBtYXAubWFwW2luZGV4XSAhPSBtYXAubWFwW2luZGV4ICsgMV0pICYmIChyb3cgPT0gMCB8fCBtYXAubWFwW2luZGV4XSAhPSBtYXAubWFwW2luZGV4IC0gbWFwLndpZHRoXSkpIHtcbiAgICAgIGNvbnN0IGNlbGxQb3MgPSBtYXAubWFwW2luZGV4XTtcbiAgICAgIGNvbnN0IHBvcyA9IHN0YXJ0ICsgY2VsbFBvcyArIHRhYmxlLm5vZGVBdChjZWxsUG9zKS5ub2RlU2l6ZSAtIDE7XG4gICAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY29sdW1uLXJlc2l6ZS1oYW5kbGVcIjtcbiAgICAgIGlmICgoX2EgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kcmFnZ2luZykge1xuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERlY29yYXRpb24yLm5vZGUoXG4gICAgICAgICAgICBzdGFydCArIGNlbGxQb3MsXG4gICAgICAgICAgICBzdGFydCArIGNlbGxQb3MgKyB0YWJsZS5ub2RlQXQoY2VsbFBvcykubm9kZVNpemUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzOiBcImNvbHVtbi1yZXNpemUtZHJhZ2dpbmdcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlY29yYXRpb25zLnB1c2goRGVjb3JhdGlvbjIud2lkZ2V0KHBvcywgZG9tKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBEZWNvcmF0aW9uU2V0Mi5jcmVhdGUoc3RhdGUuZG9jLCBkZWNvcmF0aW9ucyk7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gdGFibGVFZGl0aW5nKHtcbiAgYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb24gPSBmYWxzZVxufSA9IHt9KSB7XG4gIHJldHVybiBuZXcgUGx1Z2luMih7XG4gICAga2V5OiB0YWJsZUVkaXRpbmdLZXksXG4gICAgLy8gVGhpcyBwaWVjZSBvZiBzdGF0ZSBpcyB1c2VkIHRvIHJlbWVtYmVyIHdoZW4gYSBtb3VzZS1kcmFnXG4gICAgLy8gY2VsbC1zZWxlY3Rpb24gaXMgaGFwcGVuaW5nLCBzbyB0aGF0IGl0IGNhbiBjb250aW51ZSBldmVuIGFzXG4gICAgLy8gdHJhbnNhY3Rpb25zICh3aGljaCBtaWdodCBtb3ZlIGl0cyBhbmNob3IgY2VsbCkgY29tZSBpbi5cbiAgICBzdGF0ZToge1xuICAgICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgYXBwbHkodHIsIGN1cikge1xuICAgICAgICBjb25zdCBzZXQgPSB0ci5nZXRNZXRhKHRhYmxlRWRpdGluZ0tleSk7XG4gICAgICAgIGlmIChzZXQgIT0gbnVsbCkgcmV0dXJuIHNldCA9PSAtMSA/IG51bGwgOiBzZXQ7XG4gICAgICAgIGlmIChjdXIgPT0gbnVsbCB8fCAhdHIuZG9jQ2hhbmdlZCkgcmV0dXJuIGN1cjtcbiAgICAgICAgY29uc3QgeyBkZWxldGVkLCBwb3MgfSA9IHRyLm1hcHBpbmcubWFwUmVzdWx0KGN1cik7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IHBvcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogZHJhd0NlbGxTZWxlY3Rpb24sXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgbW91c2Vkb3duOiBoYW5kbGVNb3VzZURvd25cbiAgICAgIH0sXG4gICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlRWRpdGluZ0tleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKSAhPSBudWxsID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24gOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRyaXBsZUNsaWNrLFxuICAgICAgaGFuZGxlS2V5RG93bixcbiAgICAgIGhhbmRsZVBhc3RlXG4gICAgfSxcbiAgICBhcHBlbmRUcmFuc2FjdGlvbihfLCBvbGRTdGF0ZSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBmaXhUYWJsZXMoc3RhdGUsIG9sZFN0YXRlKSxcbiAgICAgICAgYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCB7XG4gIENlbGxCb29rbWFyayxcbiAgQ2VsbFNlbGVjdGlvbixcbiAgUmVzaXplU3RhdGUsXG4gIFRhYmxlTWFwLFxuICBUYWJsZVZpZXcsXG4gIGNsaXBDZWxscyBhcyBfX2NsaXBDZWxscyxcbiAgaW5zZXJ0Q2VsbHMgYXMgX19pbnNlcnRDZWxscyxcbiAgcGFzdGVkQ2VsbHMgYXMgX19wYXN0ZWRDZWxscyxcbiAgYWRkQ29sU3BhbixcbiAgYWRkQ29sdW1uLFxuICBhZGRDb2x1bW5BZnRlcixcbiAgYWRkQ29sdW1uQmVmb3JlLFxuICBhZGRSb3csXG4gIGFkZFJvd0FmdGVyLFxuICBhZGRSb3dCZWZvcmUsXG4gIGNlbGxBcm91bmQsXG4gIGNlbGxOZWFyLFxuICBjb2xDb3VudCxcbiAgY29sdW1uSXNIZWFkZXIsXG4gIGNvbHVtblJlc2l6aW5nLFxuICBjb2x1bW5SZXNpemluZ1BsdWdpbktleSxcbiAgZGVsZXRlQ2VsbFNlbGVjdGlvbixcbiAgZGVsZXRlQ29sdW1uLFxuICBkZWxldGVSb3csXG4gIGRlbGV0ZVRhYmxlLFxuICBmaW5kQ2VsbCxcbiAgZmluZENlbGxQb3MsXG4gIGZpbmRDZWxsUmFuZ2UsXG4gIGZpbmRUYWJsZSxcbiAgZml4VGFibGVzLFxuICBmaXhUYWJsZXNLZXksXG4gIGdvVG9OZXh0Q2VsbCxcbiAgaGFuZGxlUGFzdGUsXG4gIGluU2FtZVRhYmxlLFxuICBpc0luVGFibGUsXG4gIG1lcmdlQ2VsbHMsXG4gIG1vdmVDZWxsRm9yd2FyZCxcbiAgbW92ZVRhYmxlQ29sdW1uMiBhcyBtb3ZlVGFibGVDb2x1bW4sXG4gIG1vdmVUYWJsZVJvdzIgYXMgbW92ZVRhYmxlUm93LFxuICBuZXh0Q2VsbCxcbiAgcG9pbnRzQXRDZWxsLFxuICByZW1vdmVDb2xTcGFuLFxuICByZW1vdmVDb2x1bW4sXG4gIHJlbW92ZVJvdyxcbiAgcm93SXNIZWFkZXIsXG4gIHNlbGVjdGVkUmVjdCxcbiAgc2VsZWN0aW9uQ2VsbCxcbiAgc2V0Q2VsbEF0dHIsXG4gIHNwbGl0Q2VsbCxcbiAgc3BsaXRDZWxsV2l0aFR5cGUsXG4gIHRhYmxlRWRpdGluZyxcbiAgdGFibGVFZGl0aW5nS2V5LFxuICB0YWJsZU5vZGVUeXBlcyxcbiAgdGFibGVOb2RlcyxcbiAgdG9nZ2xlSGVhZGVyLFxuICB0b2dnbGVIZWFkZXJDZWxsLFxuICB0b2dnbGVIZWFkZXJDb2x1bW4sXG4gIHRvZ2dsZUhlYWRlclJvdyxcbiAgdXBkYXRlQ29sdW1uc09uUmVzaXplXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-tables/dist/index.js\n");

/***/ })

};
;